1
00:00:00,258 --> 00:00:01,037
你好

2
00:00:01,428 --> 00:00:01,788
好吧。

3
00:00:01,788 --> 00:00:03,953
欢迎大家。

4
00:00:04,648 --> 00:00:07,668
这里是开源星期五。

5
00:00:08,039 --> 00:00:11,912
在这里，我们会讨论开源项目维护者正在维护的项目。

6
00:00:12,244 --> 00:00:15,361
有时我们也为项目做贡献

7
00:00:16,261 --> 00:00:19,558
很高兴能邀请到尤雨溪来到我们的节目。

8
00:00:19,624 --> 00:00:20,573
尤：大家好！

9
00:00:20,865 --> 00:00:21,601
欢迎

10
00:00:21,854 --> 00:00:25,283
在你身后有 Vue 的 logo。

11
00:00:25,943 --> 00:00:26,439
尤：是的

12
00:00:26,643 --> 00:00:29,520
尤雨溪是 Vue 的创造者，也是维护者之一。

13
00:00:29,899 --> 00:00:33,297
那么就请你来自我介绍一下，告诉观众今天为什么你来到这里。

14
00:00:33,799 --> 00:00:34,518
好的

15
00:00:34,519 --> 00:00:35,568
我叫尤雨溪

16
00:00:35,569 --> 00:00:37,848
我

17
00:00:37,849 --> 00:00:39,052
我写过 Vuejs

18
00:00:39,139 --> 00:00:41,929
我是 Vuejs 的团队负责人

19
00:00:42,049 --> 00:00:47,812
但在过去的几个月里，我在做一个叫做 Vite 的项目。

20
00:00:47,959 --> 00:00:50,748
这也是我今天要讲的内容

21
00:00:50,749 --> 00:00:52,548
所以

22
00:00:52,549 --> 00:00:53,448
是的

23
00:00:53,449 --> 00:00:56,898
Vite 最初是与 Vue 相关的。

24
00:00:56,899 --> 00:01:00,625
但现在已经有了自己的东西

25
00:01:01,518 --> 00:01:06,648
我希望它能让开发者受益

26
00:01:06,649 --> 00:01:08,298
尤其是前端开发人员

27
00:01:08,299 --> 00:01:09,498
不仅仅是少数用户

28
00:01:09,499 --> 00:01:11,388
就像所有开发者的朋友一样

29
00:01:13,278 --> 00:01:13,908
很好

30
00:01:13,909 --> 00:01:14,268
是的

31
00:01:14,269 --> 00:01:15,468
它很有趣

32
00:01:15,469 --> 00:01:16,908
因为我已经肯定了

33
00:01:16,909 --> 00:01:21,498
我还以为我们上周聊了完全不同的项目

34
00:01:21,499 --> 00:01:24,528
但我从来没有听过 Vite vit 的发音。

35
00:01:24,529 --> 00:01:26,148
我之前的发音是 white

36
00:01:26,149 --> 00:01:28,098
是的

37
00:01:28,099 --> 00:01:33,588
很多人发现我不知道我选的是

38
00:01:33,589 --> 00:01:34,338
我选了名字

39
00:01:34,339 --> 00:01:36,228
它实际上是法语单词

40
00:01:36,229 --> 00:01:39,498
Vite 在法语里的意思是快速迅捷

41
00:01:39,499 --> 00:01:40,458
所以

42
00:01:41,838 --> 00:01:42,228
事实上

43
00:01:42,229 --> 00:01:42,888
也很酷

44
00:01:42,889 --> 00:01:44,988
为了坚持它最初的发音

45
00:01:44,989 --> 00:01:49,758
但是我们现在正处于两难的境地 因为有些人喜欢

46
00:01:49,759 --> 00:01:52,338
如果 Vite 的发音是法语的

47
00:01:52,339 --> 00:01:56,238
那么 Vue 为什么不用法语发音呢

48
00:01:56,239 --> 00:01:58,458
实际上 Vue 也是法语单词

49
00:01:58,459 --> 00:02:01,248
太糟糕了

50
00:02:01,249 --> 00:02:02,658
我自己的解释是

51
00:02:04,398 --> 00:02:07,758
只要坚持作者喜欢的就行了（就是尤大读什么就是什么）

52
00:02:07,759 --> 00:02:09,108
我猜

53
00:02:09,109 --> 00:02:10,218
是的

54
00:02:10,219 --> 00:02:10,488
对不起

55
00:02:10,489 --> 00:02:13,278
我只是在摆弄屏幕因为他们确实在某个地方看到了

56
00:02:13,279 --> 00:02:13,428
哦

57
00:02:13,429 --> 00:02:15,738
是法语单词 表示 快

58
00:02:15,739 --> 00:02:20,748
这些都是关于法语发音的提示就在 Readme里

59
00:02:21,126 --> 00:02:23,799
感谢 Evan 做了这些。

60
00:02:24,213 --> 00:02:24,854
很好

61
00:02:24,919 --> 00:02:28,979
那么 Vite 是什么呢，从更高的层次上来看

62
00:02:29,757 --> 00:02:31,068
就像"快速"是其中一个关键词

63
00:02:31,069 --> 00:02:32,792
那么你怎么说？

64
00:02:32,989 --> 00:02:38,264
每次人们让我解释 Vite 是什么的时候，其实有点难度的

65
00:02:39,529 --> 00:02:43,428
没有办法用简单的一句话来描述它。

66
00:02:45,648 --> 00:02:49,188
但是如果你想和你现在正在用的工具做比较

67
00:02:49,189 --> 00:02:52,848
我想市面上 Vite 最接近的产品是 Parcel。

68
00:02:52,849 --> 00:02:56,748
Vite 和 Parcel 提供的能力类似

69
00:02:56,749 --> 00:02:57,138
但是

70
00:02:58,998 --> 00:03:01,814
搜索 Parcel bundler

71
00:03:01,814 --> 00:03:01,818
谷歌帮了我

72
00:03:01,818 --> 00:03:03,163
谷歌帮了我

73
00:03:03,169 --> 00:03:03,555
是的

74
00:03:03,555 --> 00:03:03,558
但很明显，它在实现上是不同的

75
00:03:03,558 --> 00:03:07,844
但很明显，它在实现上是不同的

76
00:03:08,948 --> 00:03:13,392
而且在开发服务器上的工作原理是完全不同的。

77
00:03:14,029 --> 00:03:15,438
但就它的作用而言

78
00:03:15,439 --> 00:03:22,248
你可以把 Vite 看作是将你代码运行起来的工具。

79
00:03:22,249 --> 00:03:22,578
是的

80
00:03:22,579 --> 00:03:29,628
有趣的是，Vite 既是开发服务器也是预配置的打包器。

81
00:03:29,629 --> 00:03:33,108
我们可以称之为一个前端构建工具

82
00:03:33,109 --> 00:03:38,299
但是这种解释太普通了，人们还是不知道它是什么。

83
00:03:38,359 --> 00:03:43,608
我很难用一种非常简洁的方式来描述它

84
00:03:43,609 --> 00:03:44,358
这也是

85
00:03:44,359 --> 00:03:53,538
我想做这场直播的原因，因为我认为这种方式向人们展示它的功能和运作方式更容易

86
00:03:53,539 --> 00:03:56,118
你可以很直接地理解所有的东西

87
00:03:56,119 --> 00:03:57,408
它的样子

88
00:03:57,409 --> 00:03:58,938
理解 Vite 是什么

89
00:03:58,939 --> 00:04:00,468
是的

90
00:04:00,469 --> 00:04:02,298
我想我们实际上

91
00:04:02,299 --> 00:04:03,828
我自己做了很多前端工作

92
00:04:03,829 --> 00:04:05,295
我是 React 背景

93
00:04:05,295 --> 00:04:05,298
我也做过一些在 Github 上的 Vue 的项目

94
00:04:05,298 --> 00:04:08,231
我也做过一些在 Github 上的 Vue 的项目

95
00:04:08,556 --> 00:04:11,624
我觉得我们正在经历一场肉眼可见的革命。

96
00:04:11,629 --> 00:04:13,458
我想我们五年前就看到了

97
00:04:13,459 --> 00:04:14,268
也许会比那更早。

98
00:04:14,269 --> 00:04:17,776
就像 Webpack 逐渐被接受。

99
00:04:17,776 --> 00:04:17,778
它是一种打包工具。

100
00:04:17,778 --> 00:04:18,919
它是一种打包工具。

101
00:04:19,957 --> 00:04:22,908
我也许会把这些打包工具进行一一比较。

102
00:04:22,909 --> 00:04:25,918
因为我知道你很难描述是

103
00:04:26,779 --> 00:04:28,578
但我认为我们正在寻找一种进化

104
00:04:28,579 --> 00:04:37,218
我认为我们现在甚至看到现在一些主机服务商添加了所有些花哨的东西和新功能，就像已经为下一波浪潮做好了准备。

105
00:04:37,219 --> 00:04:41,268
这也是这股潮流被称为前沿的原因。

106
00:04:41,326 --> 00:04:42,886
这股潮流应该叫什么？

107
00:04:42,886 --> 00:04:42,888
我知道它的称号,但我甚至不知道它叫什么。

108
00:04:42,888 --> 00:04:45,105
我知道它的称号,但我甚至不知道它叫什么。

109
00:04:45,109 --> 00:04:48,468
它是下一代前端工具系统

110
00:04:48,469 --> 00:04:49,098
这就对了。

111
00:04:50,748 --> 00:04:51,528
我们很棒。

112
00:04:51,548 --> 00:04:55,608
那么为什么 Vite 在这个时间出现呢？

113
00:04:56,671 --> 00:05:01,014
我认为 Vite 本质上是 ...

114
00:05:01,040 --> 00:05:05,869
Vite 以及像 snowpack、WMR、@web/dev-server 这类

115
00:05:05,869 --> 00:05:05,871
我认为我们终于迎来了 ES 模块接近全局可用的时代了。

116
00:05:05,871 --> 00:05:15,408
我认为我们终于迎来了 ES 模块接近全局可用的时代了。

117
00:05:15,409 --> 00:05:16,382
终于。

118
00:05:17,988 --> 00:05:19,878
如果我们忽略 IE 11。

119
00:05:19,879 --> 00:05:30,288
现在所有主流浏览器的最新版本都支持原生的 ES 模块，而且现在 ESM 在 nodejs 中也可用了。

120
00:05:30,289 --> 00:05:37,398
生态系统现在终于开始做大规模的迁移战争了

121
00:05:37,399 --> 00:05:38,388
大家发现，好了，

122
00:05:38,389 --> 00:05:41,208
我们现在有标准模块系统

123
00:05:41,209 --> 00:05:43,248
而且浏览器原生支持。

124
00:05:43,249 --> 00:05:47,958
很多关于工具的假设

125
00:05:47,959 --> 00:05:49,546
特别是如果工具

126
00:05:49,546 --> 00:05:49,548
如果你假设所有的代码都是标准的 ES 模块

127
00:05:49,548 --> 00:05:53,849
如果你假设所有的代码都是标准的 ES 模块

128
00:05:55,159 --> 00:05:57,314
你可以把很多东西联系起来

129
00:05:57,314 --> 00:05:57,318
你可以将很多东西委托给浏览器或一些工具，它们只会比现有工具更快地处理特定的工作流程

130
00:05:57,318 --> 00:06:07,767
你可以将很多东西委托给浏览器或一些工具，它们只会比现有工具更快地处理特定的工作流程

131
00:06:09,319 --> 00:06:13,338
我认为这就是下一代工具的重点所在

132
00:06:13,339 --> 00:06:14,748
是

133
00:06:14,749 --> 00:06:15,078
你知道吗

134
00:06:15,079 --> 00:06:15,468
终于

135
00:06:15,469 --> 00:06:21,018
我们有了原生的标准模型系统，它将在某种程度上普及。

136
00:06:21,019 --> 00:06:34,878
我们如何重新想象工具，如何利用这个机会重新思考我们今天正在做的事情，能够更加整洁快速。

137
00:06:35,748 --> 00:06:36,318
是的

138
00:06:36,319 --> 00:06:37,993
说到快速

139
00:06:37,993 --> 00:06:37,998
我们也准备好了屏幕共享。

140
00:06:37,998 --> 00:06:41,892
我们也准备好了屏幕共享。

141
00:06:41,899 --> 00:06:49,755
我不知道我们是否想要参与进来告诉大家我们如何安装 Vite 并且使用在项目中。

142
00:06:50,179 --> 00:06:50,478
啊

143
00:06:50,479 --> 00:06:50,778
肯定的是

144
00:06:50,779 --> 00:06:51,168
是的

145
00:06:51,169 --> 00:06:54,858
我想我现在就开始分享我的屏幕

146
00:06:54,859 --> 00:06:58,218
我认为应该有了。

147
00:06:58,219 --> 00:06:58,698
好吧

148
00:06:58,699 --> 00:06:59,778
所以

149
00:06:59,779 --> 00:06:59,988
是的

150
00:06:59,989 --> 00:07:01,126
是我的屏幕

151
00:07:03,408 --> 00:07:05,298
如果你想开始

152
00:07:05,299 --> 00:07:09,828
你需要安装 nodejs，然后使用 init 命令初始化 @vitejs/app

153
00:07:09,829 --> 00:07:12,498
但真的是

154
00:07:12,499 --> 00:07:15,978
对于那些想省事的人来说的。

155
00:07:15,979 --> 00:07:17,538
但是我不打算么做

156
00:07:17,539 --> 00:07:20,058
我今天想做的是

157
00:07:20,059 --> 00:07:26,088
是全新的演示，我有一个空的文件夹

158
00:07:26,088 --> 00:07:27,257
里面什么都没有

159
00:07:27,259 --> 00:07:31,278
我使用命令： yarn add vite

160
00:07:31,279 --> 00:07:32,298
有 -D 参数

161
00:07:33,678 --> 00:07:34,865
要把它弄大点吗

162
00:07:36,888 --> 00:07:39,018
开始了

163
00:07:39,019 --> 00:07:41,268
啊？它没有滚动到最后

164
00:07:41,269 --> 00:07:41,598
为什么？

165
00:07:43,998 --> 00:07:44,658
好吧

166
00:07:44,659 --> 00:07:47,116
启动很快

167
00:07:47,116 --> 00:07:47,118
Vite 是 ...

168
00:07:47,118 --> 00:07:48,345
Vite 是 ...

169
00:07:48,349 --> 00:07:50,268
让我们看一下 node modules 文件夹

170
00:07:50,269 --> 00:07:51,318
一共 18 MB

171
00:07:51,319 --> 00:08:02,298
实际安装的模块也非常少，因为我们预先将它们打包以确保安装速度更快。

172
00:08:02,299 --> 00:08:04,488
这也是为什么

173
00:08:04,489 --> 00:08:07,008
与 create-react-app 相比

174
00:08:07,009 --> 00:08:15,528
你们会看到明显的区别就安装依赖本身而言， Vite 是更快的。

175
00:08:15,529 --> 00:08:16,578
它快了多少

176
00:08:16,579 --> 00:08:19,818
现在我们有了东西

177
00:08:22,098 --> 00:08:22,428
是的

178
00:08:22,429 --> 00:08:23,868
我有些

179
00:08:23,869 --> 00:08:26,838
我们忽略所有现有的东西 我把它放在里

180
00:08:26,839 --> 00:08:27,918
你解释一下我们在看

181
00:08:27,919 --> 00:08:28,548
是好

182
00:08:28,549 --> 00:08:30,438
这些是 node modules

183
00:08:30,439 --> 00:08:31,278
是的

184
00:08:31,279 --> 00:08:35,148
这些是你在执行 npm install 或者 yarn add 之后

185
00:08:35,149 --> 00:08:39,078
所生成的文件，它们并不重要

186
00:08:39,079 --> 00:08:41,778
我要创建一个 html 文件

187
00:08:43,758 --> 00:08:46,398
写一个 Hello

188
00:08:47,508 --> 00:08:54,588
你们可以在里执行 npx vite

189
00:08:54,589 --> 00:08:58,098
让你的终端往上一点

190
00:08:58,099 --> 00:08:58,938
好吧

191
00:08:58,939 --> 00:09:00,198
我们把它移到里

192
00:09:00,199 --> 00:09:00,498
然后

193
00:09:03,468 --> 00:09:04,068
好吧

194
00:09:04,069 --> 00:09:07,068
我只需要在 package.json 里加一个 script 命令

195
00:09:09,078 --> 00:09:11,238
"dev" : "vite"

196
00:09:13,758 --> 00:09:14,478
然后

197
00:09:16,758 --> 00:09:18,348
哦

198
00:09:18,349 --> 00:09:20,456
执行 yarn dev

199
00:09:22,518 --> 00:09:23,808
我启动了一个开发服务器。

200
00:09:25,968 --> 00:09:30,671
注意我仅仅是添加了这个脚本，其他什么都没有做

201
00:09:30,671 --> 00:09:35,897
所以至少我们可以把 Vite 看作是一个静态文件服务器。

202
00:09:36,889 --> 00:09:42,798
你也许用过 serve 或者 http 静态服务器

203
00:09:42,799 --> 00:09:43,188
无论如何

204
00:09:43,189 --> 00:09:49,872
就像你的静态文件在本地作为静态文件的目录一样

205
00:09:49,872 --> 00:09:49,878
至少一个 Vite 命令就能做到

206
00:09:49,878 --> 00:09:54,848
至少一个 Vite 命令就能做到

207
00:09:54,919 --> 00:09:55,968
大家可以看到 Hello

208
00:09:55,969 --> 00:09:58,182
这就是 index.html 的内容

209
00:09:58,182 --> 00:09:58,188
是我喜欢的我经常用 npx serve

210
00:09:58,188 --> 00:10:05,801
是我喜欢的我经常用 npx serve

211
00:10:05,809 --> 00:10:06,708
是的

212
00:10:06,709 --> 00:10:07,038
好吧

213
00:10:07,039 --> 00:10:09,018
到目前为止

214
00:10:09,019 --> 00:10:13,608
我可以得到非常类似的命令来为静态文件。

215
00:10:13,609 --> 00:10:14,868
它是静态文件服务器

216
00:10:14,869 --> 00:10:19,308
但它显然不是用来生产的

217
00:10:19,309 --> 00:10:21,197
这些都是开发时的东西

218
00:10:21,198 --> 00:10:26,926
我编辑并保存，发现无需任何配置，页面就能重新加载。

219
00:10:28,398 --> 00:10:30,258
用原生模块

220
00:10:32,148 --> 00:10:33,826
用原生的 ES 模块

221
00:10:33,826 --> 00:10:33,828
你可以写 module 类型的脚本，你可以样做

222
00:10:33,828 --> 00:10:37,305
你可以写 module 类型的脚本，你可以样做

223
00:10:39,702 --> 00:10:42,372
你可以在这行使用 import

224
00:10:42,379 --> 00:10:44,478
引入 main.js

225
00:10:44,479 --> 00:10:45,498
是的

226
00:10:45,499 --> 00:10:49,278
报错告诉你无法解析 main.js 因为它根本不存在

227
00:10:49,279 --> 00:10:50,868
我将在里创建它

228
00:10:52,188 --> 00:10:52,908
并且

229
00:10:56,238 --> 00:10:58,308
重新加载页面

230
00:10:59,328 --> 00:11:02,868
确保控制台输出了 hello

231
00:11:02,869 --> 00:11:05,388
你也可以看到 vite 连接的提示

232
00:11:05,389 --> 00:11:08,058
这是我们的热更新客户端

233
00:11:08,059 --> 00:11:11,388
正在运行

234
00:11:11,389 --> 00:11:13,848
如果你把它加到你的文件里

235
00:11:13,849 --> 00:11:15,198
它还会重新加载页面

236
00:11:16,728 --> 00:11:23,178
你可以看到 main.js 文件已经更新和重新加载了

237
00:11:23,179 --> 00:11:28,068
不是真正的 hmr，因为只是重新加载页面

238
00:11:28,069 --> 00:11:32,808
但是它会跟踪 index.html 里面所有 import 的资源

239
00:11:33,229 --> 00:11:35,778
要知道，如果你编辑文件

240
00:11:35,779 --> 00:11:36,828
我需要重新加载页面

241
00:11:36,829 --> 00:11:37,728
如果你加上其他东西

242
00:11:37,729 --> 00:11:39,168
我不需要关心它

243
00:11:41,298 --> 00:11:47,193
我们想要做的一些常见的事情是

244
00:11:48,078 --> 00:11:49,908
比如链接 CSS 文件

245
00:11:51,678 --> 00:11:55,518
我们就创建一个 style.css 文件。

246
00:11:56,718 --> 00:11:57,978
H1 标签样式设置颜色为红色。

247
00:11:59,748 --> 00:12:07,829
显然可以用 link 标签链接到 style.css 文件

248
00:12:07,866 --> 00:12:09,708
注意这里，我可以...

249
00:12:09,709 --> 00:12:14,988
因为它是http服务器 你可以使用绝对路径

250
00:12:14,989 --> 00:12:17,508
和你想的一样

251
00:12:17,509 --> 00:12:21,198
屏幕上的内容变成了红色。

252
00:12:21,199 --> 00:12:23,538
如果我在里编辑

253
00:12:23,539 --> 00:12:26,208
你你提到了绝对路径

254
00:12:26,209 --> 00:12:27,348
有人在聊天室提问

255
00:12:27,349 --> 00:12:30,228
如何在不是根目录的其他文件夹使用 Vite？

256
00:12:32,058 --> 00:12:34,218
如何从另文件夹使用它

257
00:12:34,219 --> 00:12:34,548
是的

258
00:12:34,549 --> 00:12:41,118
我想如果你有CSS样式文件夹或者你可以安装相对路径

259
00:12:41,119 --> 00:12:41,478
是的

260
00:12:41,479 --> 00:12:42,528
你可以用相对路径

261
00:12:42,529 --> 00:12:45,048
你甚至可以有一些想法

262
00:12:45,049 --> 00:12:49,848
它还遵循了所有的 npm node 模块解析算法。

263
00:12:49,849 --> 00:12:50,238
好吧

264
00:12:50,239 --> 00:12:53,028
我们一会儿就会看到

265
00:12:53,029 --> 00:12:53,808
但正如你所见

266
00:12:53,809 --> 00:12:59,268
就像简单的 link 标签，请注意

267
00:12:59,269 --> 00:13:01,038
当我编辑的时候

268
00:13:01,039 --> 00:13:03,798
页面实际上没有重新加载

269
00:13:03,808 --> 00:13:07,668
它是热更新 CSS

270
00:13:07,669 --> 00:13:15,468
这是怎么做到的？是 Vite 的魔法吗？

271
00:13:15,469 --> 00:13:15,856
是的

272
00:13:15,856 --> 00:13:15,858
Vite 做了记录文件关系的工作

273
00:13:15,858 --> 00:13:18,975
Vite 做了记录文件关系的工作

274
00:13:18,979 --> 00:13:25,728
我想指出的一点是，我们大量的用户都是来自于 webpack

275
00:13:25,729 --> 00:13:33,438
他们习惯于将 main.js 作为应用程序的入口点，而 HTML 则是事后的想法。

276
00:13:33,439 --> 00:13:37,398
而对于 Vite 可以把它看作是服务器。

277
00:13:37,399 --> 00:13:46,822
因此 HTML 实际上是入口，Vite 实际上会解析里面的所有内容，把它当作是一个模块图的入口。

278
00:13:47,029 --> 00:13:51,108
所以 CSS 样式也被认为是模块图的一部分

279
00:13:51,108 --> 00:13:57,378
这里会变成内联模块，它导入的 main.js 是另一个模块 。

280
00:13:57,379 --> 00:14:01,338
因此，请注意 index.html 实际上是应用程序的入口。

281
00:14:01,339 --> 00:14:03,048
从那里开始

282
00:14:03,049 --> 00:14:05,838
我们构建了应用程序的整个模块图。

283
00:14:05,839 --> 00:14:06,927
我们不是从 main.js 开始

284
00:14:07,002 --> 00:14:13,068
之前他们会倒着去找出 html 是什么样子。

285
00:14:13,069 --> 00:14:14,898
这就是问题所在

286
00:14:14,899 --> 00:14:22,008
很多人需要按下开关才能开始适应 Vite

287
00:14:22,009 --> 00:14:24,258
我认为 Parcel 也是类似的。

288
00:14:24,259 --> 00:14:29,478
Parcel 是将 HTML 作为入口和模块图的一部分概念的先驱。

289
00:14:29,479 --> 00:14:32,958
我认为对于 web 开发者而言，

290
00:14:32,959 --> 00:14:34,668
在特定的

291
00:14:34,669 --> 00:14:36,378
是你给我的东西

292
00:14:36,379 --> 00:14:39,528
是一种更自然的思维模式

293
00:14:39,529 --> 00:14:40,813
但在某种程度上 对吗

294
00:14:40,813 --> 00:14:40,818
Vite 背后的原理呢是我们记录了 HTML 和 CSS 文件之间的所有些重要关系。

295
00:14:40,818 --> 00:14:50,568
Vite 背后的原理呢是我们记录了 HTML 和 CSS 文件之间的所有些重要关系。

296
00:14:52,728 --> 00:14:54,108
我们可以

297
00:14:54,109 --> 00:14:58,788
我们只需要更新链接的 CSS

298
00:14:58,789 --> 00:15:01,038
对吗？

299
00:15:01,039 --> 00:15:05,088
这里和静态文件服务器没有太大区别。

300
00:15:05,089 --> 00:15:08,088
我们还做了一些开箱即用的事情

301
00:15:10,728 --> 00:15:15,094
假设我们新建一个 style.module.css 文件。

302
00:15:16,638 --> 00:15:18,280
我要说...

303
00:15:18,806 --> 00:15:22,458
这个 module 关键字是什么，我们之前没有见过

304
00:15:22,459 --> 00:15:24,168
是一个约定

305
00:15:24,169 --> 00:15:26,988
如果你使用过 CSS 模块

306
00:15:26,989 --> 00:15:30,732
用 .module.css 来命名文件是一种约定

307
00:15:32,000 --> 00:15:37,338
在 Vite 里这也是一个约定， 我们看到这样命名的文件

308
00:15:37,339 --> 00:15:38,178
这里要写...

309
00:15:40,458 --> 00:15:41,058
.text

310
00:15:42,973 --> 00:15:43,663
颜色

311
00:15:44,928 --> 00:15:45,438
红色的

312
00:15:46,514 --> 00:15:49,304
我要把这块注释掉

313
00:15:50,298 --> 00:15:54,258
在这里 import classes from

314
00:15:55,638 --> 00:16:01,128
style.module.css

315
00:16:01,129 --> 00:16:03,528
我们把它打印出来

316
00:16:03,529 --> 00:16:04,728
如你所见

317
00:16:04,729 --> 00:16:07,213
一个带有 text 对象

318
00:16:08,238 --> 00:16:09,618
这是类名

319
00:16:09,619 --> 00:16:10,818
这里写...

320
00:16:12,738 --> 00:16:16,128
document.querySelector

321
00:16:17,747 --> 00:16:19,698
h1.className

322
00:16:19,699 --> 00:16:23,508
等于 classes.text

323
00:16:25,902 --> 00:16:29,202
现在这里又变回了红色。

324
00:16:29,209 --> 00:16:32,298
如果你编辑这里

325
00:16:32,299 --> 00:16:33,858
它还重新加载

326
00:16:33,859 --> 00:16:35,898
不是置换的量

327
00:16:35,899 --> 00:16:37,848
但是但是你的想法是正确的

328
00:16:37,849 --> 00:16:40,248
我们有很多约定

329
00:16:40,249 --> 00:16:42,168
想象一下如果你是

330
00:16:42,169 --> 00:16:44,988
如果你之前有使用纯 webpack 的项目

331
00:16:44,989 --> 00:16:49,038
现在你想使用 CSS 模块

332
00:16:50,449 --> 00:16:54,816
你需要通过指南来学习 CSS Loader 和 Style Loader。

333
00:16:54,852 --> 00:16:56,767
是的，我之前就是这个学校路线。

334
00:16:57,762 --> 00:17:04,488
如果你想使用 PostCSS，你需要查找其对应的 CSS Loader 配置，然后再把这些 loaders 添加进 webpack 的配置中去。

335
00:17:04,489 --> 00:17:05,718
你明白我的意思了

336
00:17:05,719 --> 00:17:09,648
Vite 的概念是很有主见的。

337
00:17:09,649 --> 00:17:20,238
它有很多内置的东西，它可以某种程度上减轻你做某些事情的障碍。

338
00:17:20,239 --> 00:17:20,836
同样的

339
00:17:20,836 --> 00:17:20,838
如果你想要自定义 PostCSS 配置，

340
00:17:20,838 --> 00:17:24,525
如果你想要自定义 PostCSS 配置，

341
00:17:24,529 --> 00:17:26,778
你只需要新建 postcss.cofig.js 文件

342
00:17:27,918 --> 00:17:30,348
导出 css 配置

343
00:17:30,349 --> 00:17:30,918
是

344
00:17:32,478 --> 00:17:35,823
这和你使用 Tailwind CSS 类似。

345
00:17:35,823 --> 00:17:35,827
因为 Tailwind 本身就是 Post CSS 插件。

346
00:17:35,827 --> 00:17:39,315
因为 Tailwind 本身就是 Post CSS 插件。

347
00:17:40,009 --> 00:17:42,558
如果你配置

348
00:17:42,559 --> 00:17:45,858
你想要在 Vite 中使用 Tailwind

349
00:17:45,859 --> 00:17:47,538
啊

350
00:17:47,539 --> 00:17:48,468
让我们看看

351
00:17:48,469 --> 00:17:50,147
我们怎么才能把它解决掉呢

352
00:17:50,148 --> 00:17:53,146
自豪的去 Tailwind CSS 网站

353
00:17:55,188 --> 00:17:57,558
我要去搜索 Vite

354
00:17:57,559 --> 00:18:00,198
我想里有指南有关于 Vite 的配置。

355
00:18:00,199 --> 00:18:01,038
是的

356
00:18:01,039 --> 00:18:02,148
你为什么要找这个？

357
00:18:02,149 --> 00:18:04,518
聊天室里有一些问题

358
00:18:04,519 --> 00:18:09,738
Vite 有没有和 creat-react-app 类似的 eject 特性？

359
00:18:11,118 --> 00:18:16,308
我认为真的没有必要 eject。

360
00:18:16,309 --> 00:18:18,708
Vite 有自己的配置格式

361
00:18:18,709 --> 00:18:21,948
但并不是基于 webpack 的概念

362
00:18:21,949 --> 00:18:24,588
因为 CSS 模块只是在 Vite 中运行

363
00:18:24,589 --> 00:18:28,638
如果你想要配置它，可以，

364
00:18:28,639 --> 00:18:35,238
我们可以创建 vite.config.js 文件，在里面 export default

365
00:18:36,858 --> 00:18:39,461
css modules

366
00:18:39,750 --> 00:18:47,059
这些选项会被传到 Post CSS 模块上，你可以这么配置

367
00:18:47,206 --> 00:18:49,597
localsConvention

368
00:18:49,848 --> 00:18:51,828
camelCaseOnly

369
00:18:52,758 --> 00:18:57,708
如果你使用过 CSS 模块，你就知道这个配置的作用。

370
00:18:57,709 --> 00:19:01,428
但像大多数构建东西一样 也是可配置的

371
00:19:01,429 --> 00:19:02,388
但问题是

372
00:19:04,008 --> 00:19:07,578
我个人的看法是因为我工作过 ...

373
00:19:07,579 --> 00:19:12,258
我们维护了 Vue CLI，它是基于 webpack 的。

374
00:19:12,259 --> 00:19:17,778
我们倾注了极大热情，把很多些东西从箱子里拿出来。

375
00:19:17,779 --> 00:19:22,608
在某种程度上，如果你用 Vite 来驱动 Vue 项目

376
00:19:22,609 --> 00:19:30,918
在操作源代码时，你可能会害怕使用 Vue CLI 相同的特性集合。

377
00:19:30,919 --> 00:19:36,768
但我们必须在内部维护一个相当复杂的 webpack 配置。

378
00:19:36,769 --> 00:19:42,078
当人们想要配置它时，通常是相当复杂的

379
00:19:43,038 --> 00:19:49,128
Vite 的想法基本上是我们提炼出来的

380
00:19:49,129 --> 00:19:50,898
我们知道的很多事情

381
00:19:50,899 --> 00:19:55,788
就像用户在典型的项目中需要

382
00:19:55,789 --> 00:19:57,528
还因为

383
00:19:57,529 --> 00:19:58,758
随着时间的推移

384
00:19:58,759 --> 00:20:04,938
我们在 Vue CLI 的维护中得出结论，是一种合适的默认配置。

385
00:20:04,939 --> 00:20:06,558
大多数人都想要

386
00:20:06,559 --> 00:20:10,938
我们也将它作为 Vite 的默认配置

387
00:20:10,939 --> 00:20:14,028
如果有一些事情

388
00:20:14,029 --> 00:20:16,278
我们知道用户想要自定义

389
00:20:16,279 --> 00:20:17,808
我们通过配置选项暴露出来。

390
00:20:19,908 --> 00:20:20,808
加上插件系统

391
00:20:20,809 --> 00:20:23,328
Vite 也很灵活

392
00:20:23,329 --> 00:20:26,598
但我不认为我们今天要深入研究这个。

393
00:20:28,789 --> 00:20:31,548
我想理解了些惯例

394
00:20:31,549 --> 00:20:38,654
就像我刚才说的打包工具现在已经进步了，人们开始探索下一代的新东西。

395
00:20:39,349 --> 00:20:44,538
我喜欢的事实是，现在有强烈的意见发生在前端 JavaScript 世界里。

396
00:20:44,539 --> 00:20:51,318
因为当你说到 webpack 的时候，我就想起了肯我想用新东西的时候

397
00:20:51,319 --> 00:20:52,968
就像当时的 Tailwind CSS

398
00:20:52,969 --> 00:21:03,468
但我不知道怎么把它放进我的 webpack 配置里，因为有时候几个插件会相互冲突。

399
00:21:03,469 --> 00:21:04,968
有时我需要两者

400
00:21:04,969 --> 00:21:09,378
我已经被那种情况搞得筋疲力尽了

401
00:21:09,379 --> 00:21:13,458
但听起来在 Vite 中，这些步骤都是开箱即用的。

402
00:21:13,459 --> 00:21:13,848
是的

403
00:21:13,849 --> 00:21:25,600
我觉得 Vite 属于更"固执己见的"， 是不同的价值主张，工具想要在何种层次中生存也是不同的。

404
00:21:25,909 --> 00:21:30,228
我认为 webpack 本身仍然是处在非常低的水平。

405
00:21:30,229 --> 00:21:40,608
缺点是当处于这么低的抽象程度，但还希望允许所有更高级别的特性都可以配置，

406
00:21:40,609 --> 00:21:43,548
复杂性就会爆炸

407
00:21:43,549 --> 00:21:44,718
而如果是你

408
00:21:44,719 --> 00:21:46,158
如果工具进来说

409
00:21:46,159 --> 00:21:46,368
嘿

410
00:21:46,369 --> 00:21:47,718
我只是想"固执己见"，

411
00:21:47,719 --> 00:21:58,308
我可以为用户管理更多的东西，因为工具把这些东西聚合在了一起协同工作。

412
00:21:58,309 --> 00:22:03,378
所有的系统都更加流畅，因为在工具层有更多的控制

413
00:22:03,379 --> 00:22:11,778
而不是强迫用户去弄清楚所有，比如如何让功能 A 与功能 B 兼容

414
00:22:11,779 --> 00:22:25,608
我认为你可以让所有的 loaders 和 plugins 与 webpack 放到一起工作简直是个奇迹。

415
00:22:26,718 --> 00:22:27,588
但你知道

416
00:22:29,346 --> 00:22:34,096
我认为我们得出的结论是，大多数用户都不想面对种情况。

417
00:22:34,699 --> 00:22:40,488
如果工具已经能够以一种"固执己见"的方式为他们处理些东西

418
00:22:40,489 --> 00:22:45,018
他们很乐意跟着我们走

419
00:22:45,019 --> 00:22:46,128
我想也需要一些

420
00:22:46,129 --> 00:22:46,398
因为

421
00:22:46,399 --> 00:22:50,928
作为生态系统和社区也需要

422
00:22:50,929 --> 00:22:53,718
我们需要一些像 webpack 的工具来铺路

423
00:22:53,719 --> 00:22:57,408
我们尝试在 webpack 的上层，

424
00:22:57,409 --> 00:22:57,978
我们意识到

425
00:22:57,979 --> 00:22:58,398
好吧

426
00:22:58,399 --> 00:23:04,758
我们最终达成了比如关于于如何处理 CSS 的约定，

427
00:23:04,759 --> 00:23:07,428
如何处理类型的功能。

428
00:23:07,429 --> 00:23:09,288
如果你从另角度看

429
00:23:09,289 --> 00:23:12,858
像 create-react-app or Vue-CLI or Next.js

430
00:23:12,859 --> 00:23:15,348
很多东西都是大家共享的，不是吗。

431
00:23:15,349 --> 00:23:17,778
他们在 webpack 之上做了很多类似的事情。

432
00:23:17,779 --> 00:23:21,108
我想我们终于找到了他的弱点

433
00:23:21,109 --> 00:23:26,088
大多数用户几乎认为其中一些是理所当然的

434
00:23:26,089 --> 00:23:26,628
他们认为

435
00:23:26,629 --> 00:23:26,928
哦

436
00:23:26,929 --> 00:23:29,328
使用 import CSS 是很自然的，

437
00:23:29,329 --> 00:23:34,578
可以直接使用 PostCSS 也是自然的。

438
00:23:34,579 --> 00:23:37,878
我认为 Vite 在某种程度上

439
00:23:37,879 --> 00:23:38,748
就像

440
00:23:38,749 --> 00:23:39,198
好的

441
00:23:39,199 --> 00:23:41,748
如果人们已经习惯了

442
00:23:41,749 --> 00:23:46,308
我们就可以直接提供开箱即用的功能。

443
00:23:48,648 --> 00:23:51,168
我们来看看提问。

444
00:23:51,169 --> 00:23:54,048
我们刚刚看到你用了很多 Vite 命令。

445
00:23:54,049 --> 00:23:55,278
怎么样

446
00:23:55,279 --> 00:23:59,778
Vite 和 Vue CLI 最终会一起工作吗，

447
00:23:59,779 --> 00:24:02,148
还是它们现在就已经一起工作了呢？

448
00:24:02,149 --> 00:24:05,358
它们现在不一起工作，因为 Vue CLI 现在仍然是基于 webpack 的。

449
00:24:05,359 --> 00:24:07,548
从长远来看

450
00:24:07,549 --> 00:24:13,188
我们最终想要将 Vue CLI 迁移到基于 Vite 上来。

451
00:24:15,288 --> 00:24:19,308
Vue CLI 在范围上比 Vite 更高，

452
00:24:19,309 --> 00:24:22,848
因为它还包括脚手架

453
00:24:22,849 --> 00:24:25,458
它有更多的内置脚手架

454
00:24:25,459 --> 00:24:27,528
它有

455
00:24:27,529 --> 00:24:34,818
还有插件系统，我不确定迁移到 Vite 之后，这个系统是否还要保留。

456
00:24:34,819 --> 00:24:46,848
但 Vue CLI 处在更高的层次，它有更多脚手架，也给你更多约束性的集成，如测试运行器和很多其功能。

457
00:24:46,849 --> 00:24:49,638
所以 Vue CLI 是更完整的解决方案。

458
00:24:49,639 --> 00:24:50,148
所以

459
00:24:51,228 --> 00:24:51,798
有趣的是

460
00:24:51,799 --> 00:24:52,158
是的

461
00:24:52,159 --> 00:24:56,718
Vite 层次高于 webpack，但低于 Vue CLI，它介于二者之间。

462
00:24:59,298 --> 00:25:00,678
明白了。

463
00:25:00,679 --> 00:25:00,918
是的

464
00:25:00,919 --> 00:25:01,668
我的意思是

465
00:25:01,669 --> 00:25:04,608
我很期待看到 Vite 能融合到 Vue CLI 中。

466
00:25:04,609 --> 00:25:08,538
我很喜欢你关于 CLI 的观点，

467
00:25:08,539 --> 00:25:15,348
我花了很多时间研究不同的框架和不同的项目

468
00:25:15,349 --> 00:25:16,488
尤其是在我的角色里

469
00:25:16,489 --> 00:25:16,938
我回家

470
00:25:16,939 --> 00:25:20,838
你知道的 我们只是随机地运送一些东西再转移到下一件东西上

471
00:25:20,839 --> 00:25:22,998
我觉得就开发原始的东西一样，

472
00:25:22,999 --> 00:25:28,188
我想你们会喜欢的人他们会在代理机构做很多的制作网站

473
00:25:28,189 --> 00:25:29,328
我的问题是

474
00:25:29,329 --> 00:25:30,948
Vite

475
00:25:30,949 --> 00:25:35,568
能否在 JavaScript 生态系统中的其他框架上扩展呢？

476
00:25:35,569 --> 00:25:36,048
是的

477
00:25:36,049 --> 00:25:36,378
是的

478
00:25:36,379 --> 00:25:37,758
当然

479
00:25:37,759 --> 00:25:39,468
我们有

480
00:25:39,469 --> 00:25:41,658
有几种不同的方法来看待它

481
00:25:41,659 --> 00:25:42,408
首先

482
00:25:42,409 --> 00:25:44,268
Vite 与框架无关，

483
00:25:44,269 --> 00:25:49,008
因此，可以使用 Vite 来处理几乎任何框架。

484
00:25:49,009 --> 00:26:00,468
而且 Vite 提供了定义得非常好的 JavaScript API ，这样你就可以在更高级别的工具中使用 Vite 了.

485
00:26:00,469 --> 00:26:03,438
一个例子是 VitePress，

486
00:26:03,439 --> 00:26:07,968
是基于 Vite 的静态的网站生成器。

487
00:26:07,969 --> 00:26:12,588
VitePress 在内部使用 Vite 并添加了一系列约定配置。

488
00:26:12,589 --> 00:26:16,548
我可以带你看看。

489
00:26:16,549 --> 00:26:18,228
稍微看一下

490
00:26:18,229 --> 00:26:19,308
你有准备好的吗？

491
00:26:20,388 --> 00:26:21,108
其实没有

492
00:26:21,109 --> 00:26:21,738
但如果是样

493
00:26:21,739 --> 00:26:30,348
很酷，因为我更像演示它如何工作的，而不是仅仅谈论它。

494
00:26:30,349 --> 00:26:30,978
实际上

495
00:26:30,979 --> 00:26:31,638
是的

496
00:26:31,639 --> 00:26:32,538
我个人

497
00:26:32,539 --> 00:26:32,628
我

498
00:26:32,629 --> 00:26:34,068
我们之前谈过，我们在直播，

499
00:26:34,069 --> 00:26:40,098
但我知道的是，很多观众都是第一次来到 Open Souce Friday.

500
00:26:40,099 --> 00:26:43,368
我们在这里谈论开源项目，

501
00:26:43,369 --> 00:26:51,948
打开浏览器，和播客不同，在播客里你会得到很多高水平的内容，通过不同的模式，但是不会像这样实时的展示，

502
00:26:51,949 --> 00:26:59,907
我们会看演示稿，但是能在面前看到真实的例子实在是太好了。

503
00:27:01,772 --> 00:27:08,463
好的，我要快速地过一下 Tailwind， 因为这里只是安装了一些依赖。

504
00:27:08,539 --> 00:27:10,608
我要用 yarn add

505
00:27:11,568 --> 00:27:15,288
-D 和所有这些 Tailwind 相关的包

506
00:27:15,289 --> 00:27:19,218
这些就是 Tailwind 需要你安装的标准的依赖。

507
00:27:20,928 --> 00:27:22,218
安装好之后

508
00:27:22,219 --> 00:27:24,138
输入 tailwind

509
00:27:25,458 --> 00:27:28,518
tailwindcss init -P

510
00:27:31,818 --> 00:27:45,738
如果你想知道为我为什么能够在没用 npx 前缀的情况下运行它，因为我将当前路径的 node_modules 配置到了环境变量中。

511
00:27:46,818 --> 00:27:53,418
因此，我总是可以不带前缀调用 node_modules 里面的命令

512
00:27:53,419 --> 00:27:53,748
好的

513
00:27:53,749 --> 00:27:57,108
这是你自己配置的开发环境。

514
00:27:57,109 --> 00:27:57,318
是的

515
00:27:57,319 --> 00:27:59,148
是我常做的事

516
00:28:00,288 --> 00:28:00,708
好吧

517
00:28:00,709 --> 00:28:00,978
我的意思是

518
00:28:00,979 --> 00:28:07,338
我喜欢这个节目的另一原因是，我可以从其他人那里学习如何写代码，感觉是在为你们编程

519
00:28:07,339 --> 00:28:09,768
但我真的是坐在副驾驶座上

520
00:28:09,769 --> 00:28:10,638
观看新代码

521
00:28:11,628 --> 00:28:12,708
是的

522
00:28:12,709 --> 00:28:14,418
我喜欢种酷

523
00:28:16,729 --> 00:28:17,568
稍微说了一句

524
00:28:18,858 --> 00:28:23,538
我创建了 Tailwind 的配置，在 postcss.config.js 里

525
00:28:23,539 --> 00:28:26,298
里没有特别的事情要做

526
00:28:26,299 --> 00:28:29,598
除了一点，

527
00:28:29,599 --> 00:28:30,468
有点

528
00:28:32,328 --> 00:28:34,698
有些具体的配置，请忽略这些

529
00:28:34,699 --> 00:28:38,088
因为这是 tailwind 的特殊配置

530
00:28:38,089 --> 00:28:41,688
但是你需要复制并放到里的源码

531
00:28:44,118 --> 00:28:48,138
取消注释

532
00:28:49,728 --> 00:28:51,318
好了

533
00:28:51,319 --> 00:28:56,988
页面实际上已经重新加载了，我认为 tailwind css 应该已经加载了，

534
00:28:56,989 --> 00:28:57,978
我想

535
00:28:59,958 --> 00:29:03,678
我没怎么用过 tailwind css

536
00:29:03,679 --> 00:29:07,578
我觉得应该这么写： class = 3xl

537
00:29:07,579 --> 00:29:08,508
没生效吗？

538
00:29:08,509 --> 00:29:08,868
确实没有生效

539
00:29:11,688 --> 00:29:12,048
实际上

540
00:29:12,049 --> 00:29:13,518
如果有人想当 tailwind 专家，

541
00:29:13,519 --> 00:29:16,038
如果你想放弃任何东西

542
00:29:16,039 --> 00:29:16,188
哦

543
00:29:16,189 --> 00:29:17,058
需要加 text- 前缀

544
00:29:17,059 --> 00:29:19,758
text-3xl

545
00:29:19,759 --> 00:29:22,774
这也是一点，观众能看到我们在 Twitch 上在线编程。

546
00:29:23,119 --> 00:29:29,688
啊，没有生效，我们来看看是什么原因。

547
00:29:29,689 --> 00:29:30,733
让我们看看。

548
00:29:32,449 --> 00:29:33,618
我不知道你开没开聊天窗口，

549
00:29:33,619 --> 00:29:39,198
但 text-3xl...

550
00:29:39,199 --> 00:29:41,778
所有人都在搜你看的文档，

551
00:29:41,779 --> 00:29:43,098
是的

552
00:29:43,099 --> 00:29:43,278
好吧

553
00:29:43,279 --> 00:29:51,588
实际上 index.html 没有更新， 哦， 原来在这里我把 h1 的样式给覆盖了啊！

554
00:29:51,589 --> 00:29:53,058
现在 class 是 text-3xl 了

555
00:29:53,059 --> 00:29:56,778
但是对应的 CSS 仍然没有生效，

556
00:29:56,779 --> 00:30:01,218
里我想展示的另一件很酷的事是，你可以看到我现场调试 Vite,

557
00:30:01,219 --> 00:30:03,978
因为我们不需要捏造一切

558
00:30:03,979 --> 00:30:08,628
最简单的调试方法是查看network选项卡

559
00:30:08,629 --> 00:30:12,258
Vite 的每个模块都是单独的请求

560
00:30:12,259 --> 00:30:18,228
我们看 styel.css 文件，它什么也没做，

561
00:30:18,229 --> 00:30:18,588
是的

562
00:30:18,589 --> 00:30:21,453
我想是因为我没有重启服务器。

563
00:30:21,636 --> 00:30:28,458
没有导入 tailwind 库是吗

564
00:30:28,459 --> 00:30:29,088
好了，

565
00:30:29,089 --> 00:30:29,328
啊

566
00:30:29,329 --> 00:30:30,018
有好的

567
00:30:30,019 --> 00:30:31,518
事情发生了变化

568
00:30:31,519 --> 00:30:31,968
是的

569
00:30:31,969 --> 00:30:39,378
我重启了服务器，因为之前缓存了，不知道 post css 的配置。

570
00:30:39,379 --> 00:30:40,128
在我们开始之前

571
00:30:40,129 --> 00:30:41,688
我添加了 postcss 的配置，

572
00:30:41,689 --> 00:30:44,868
服务器说：我没注意到

573
00:30:44,869 --> 00:30:45,798
它已经在里

574
00:30:48,019 --> 00:30:51,408
原来尤雨溪也需要调试啊

575
00:30:51,409 --> 00:30:55,218
有时我心血来潮就会写出行代码

576
00:30:55,219 --> 00:30:55,968
是的

577
00:30:55,969 --> 00:30:56,268
好的

578
00:30:56,269 --> 00:30:58,878
再看看 index.html

579
00:30:58,879 --> 00:31:02,178
我们是不是没导入 tailwind CSS 的文件，哦，导入了，明白了。

580
00:31:02,179 --> 00:31:03,618
我们用的是 link

581
00:31:03,619 --> 00:31:05,178
样式生效了

582
00:31:05,179 --> 00:31:05,898
如你所见

583
00:31:05,899 --> 00:31:09,528
PostCSS 也可以通过些正常的链接引入。

584
00:31:09,529 --> 00:31:15,018
因为它在 Vite 中也被视为一种依赖，

585
00:31:15,019 --> 00:31:19,188
如果你在CSS文件中嵌套了 import ，

586
00:31:19,189 --> 00:31:20,658
我们也会追踪所有些

587
00:31:20,659 --> 00:31:24,288
我们也会记录模块图和依赖链路。

588
00:31:24,289 --> 00:31:28,158
你在 CSS 文件嵌套的 import 的文件，

589
00:31:28,160 --> 00:31:31,008
我们也会热更新。

590
00:31:32,209 --> 00:31:33,078
啊

591
00:31:33,079 --> 00:31:33,378
好吧

592
00:31:33,379 --> 00:31:38,058
如果我认为我们可以结束 CSS 的部分了。

593
00:31:38,059 --> 00:31:38,598
实际上，

594
00:31:40,008 --> 00:31:44,252
也许还可以展示一些东西，比如

595
00:31:44,643 --> 00:31:48,108
yarn add -D sass

596
00:31:49,938 --> 00:31:57,228
我只安装了 sass，然后创建新文件，style.scss

597
00:31:59,118 --> 00:32:00,348
颜色

598
00:32:01,428 --> 00:32:03,558
红色，语法是这样的吗？

599
00:32:06,768 --> 00:32:09,378
我写过一些 scss

600
00:32:10,848 --> 00:32:13,338
我要像这样把它们链接起来

601
00:32:18,588 --> 00:32:19,518
所以

602
00:32:19,519 --> 00:32:19,788
是的

603
00:32:19,789 --> 00:32:23,748
安装了 sass 依赖，就可以用 sass 或 scss 了

604
00:32:23,749 --> 00:32:25,188
它能够正常工作

605
00:32:25,189 --> 00:32:25,758
当然

606
00:32:25,759 --> 00:32:29,568
如果你愿意，也可以像这样导入 scss 文件

607
00:32:30,828 --> 00:32:31,848
这两种是一样的。

608
00:32:36,378 --> 00:32:38,898
你也可以么做

609
00:32:42,468 --> 00:32:43,698
是

610
00:32:46,368 --> 00:32:49,231
这样也可以。

611
00:32:49,231 --> 00:32:55,518
你所期望的大部分情况都能正常运行。

612
00:32:59,748 --> 00:33:07,578
这里没有生效是因为在 main.js 中没引入 style.scss，我们来引入它

613
00:33:08,418 --> 00:33:09,648
页面重新加载了

614
00:33:12,738 --> 00:33:15,648
我们快速回到 vite 配置文件

615
00:33:15,649 --> 00:33:17,328
我们没有做太多准备

616
00:33:17,329 --> 00:33:19,758
我们确实创造了一些后期增长

617
00:33:19,759 --> 00:33:22,248
我们之前有个配置

618
00:33:22,249 --> 00:33:24,318
那个配置没用

619
00:33:24,319 --> 00:33:24,798
是的

620
00:33:24,799 --> 00:33:25,878
项工作

621
00:33:25,879 --> 00:33:27,048
是的，

622
00:33:27,049 --> 00:33:32,718
我知道这些其实不是必要的 ，因为我刚刚展示了如何配置 CSS 模块

623
00:33:32,719 --> 00:33:33,198
好吧

624
00:33:33,199 --> 00:33:33,768
优秀的

625
00:33:33,769 --> 00:33:34,848
是的

626
00:33:34,849 --> 00:33:36,228
从技术上讲

627
00:33:36,229 --> 00:33:39,768
就像任何你不需要的东西，就删掉它们

628
00:33:39,769 --> 00:33:42,279
也不会影响你

629
00:33:42,420 --> 00:33:47,012
你如果只需要 sass，这就是你需要做的事情。

630
00:33:47,886 --> 00:34:02,719
如果你想走非常非常小的路线，就像这里你只需要 HTML、CSS 和 Javascript 以及可选的 CSS 预处理器这些静态文件。

631
00:34:02,768 --> 00:34:09,577
它除了可以神奇地知道一些你想用的东西之外和静态文件服务器没什么区别。

632
00:34:10,819 --> 00:34:11,208
好吧

633
00:34:11,209 --> 00:34:11,568
所以

634
00:34:13,098 --> 00:34:18,768
这是给那些想要更聪明服务器的人的。

635
00:34:18,769 --> 00:34:20,808
但很明显，我们可以做的远不止这些。

636
00:34:22,419 --> 00:34:26,538
我这有一个例子，因为我们今年在 twitch 上做了很多直播。

637
00:34:26,539 --> 00:34:30,408
上周我和米歇尔刚刚进行了直播。

638
00:34:30,409 --> 00:34:31,938
来自澳大利亚的米歇尔

639
00:34:31,939 --> 00:34:33,258
尽管我在做区分

640
00:34:33,259 --> 00:34:36,138
我们创建了一个 twitch 机器人

641
00:34:36,139 --> 00:34:38,438
我注意到的一件事是 OBS

642
00:34:38,438 --> 00:34:41,654
我们现在是用 OBS 来将屏幕的画面展示出来的。

643
00:34:42,363 --> 00:34:50,350
它是有 JavaScript 运行时，我在使用 OBS 里面的 Deno 和 js time 时很混乱。

644
00:34:50,479 --> 00:34:52,998
我还没有真正发布过任何有用的东西

645
00:34:52,999 --> 00:34:56,478
但我比较好奇的是，我们讨论过了 typescript，

646
00:34:56,479 --> 00:35:00,612
但是像 Deno 的兼容性怎么样呢？

647
00:35:01,065 --> 00:35:03,318
Deno 是...

648
00:35:03,319 --> 00:35:07,998
Deno 则完全是另一回事，因为它自成体系。

649
00:35:07,999 --> 00:35:11,878
Vite 目前是基于 Node.js 的 API 的。

650
00:35:11,929 --> 00:35:15,108
所以不支持 Deno 。

651
00:35:15,109 --> 00:35:15,558
好吧

652
00:35:15,559 --> 00:35:16,248
明白了。

653
00:35:18,468 --> 00:35:18,768
好吧

654
00:35:18,769 --> 00:35:21,918
看看接下来我们能做什么。

655
00:35:23,808 --> 00:35:26,088
我现在要添加依赖。

656
00:35:26,089 --> 00:35:28,038
我们说

657
00:35:28,039 --> 00:35:30,558
我想用 React。

658
00:35:34,158 --> 00:35:39,258
我在 main.js 里加入了 react 和 react-dom。

659
00:35:39,259 --> 00:35:43,128
我们把 main.js 后缀改为 .jsx，因为我们要在这里使用 JSX语法。

660
00:35:44,958 --> 00:35:47,808
import React from 'react';

661
00:35:49,249 --> 00:35:50,088
啊

662
00:35:51,198 --> 00:35:51,858
导入

663
00:35:53,058 --> 00:35:55,128
import ReactDom from 'react-dom'

664
00:35:55,129 --> 00:35:56,268
我想应该是这么写

665
00:35:58,368 --> 00:36:02,230
请原谅我，因为我 ...( React 不是很熟）

666
00:36:02,309 --> 00:36:06,513
ReactDom.render

667
00:36:07,728 --> 00:36:09,899
我们都在围观尤雨溪写 React。

668
00:36:11,868 --> 00:36:14,868
getElementById app,

669
00:36:14,869 --> 00:36:15,318
也许是

670
00:36:16,998 --> 00:36:20,718
这意味着我们在这里需要加一些东西

671
00:36:20,719 --> 00:36:23,287
 

672
00:36:27,378 --> 00:36:32,598
我这里要展示的并不是 React ...

673
00:36:32,599 --> 00:36:34,008
但我们需要 App 组件

674
00:36:34,009 --> 00:36:34,908
So function App.

675
00:36:39,438 --> 00:36:40,938
return hello

676
00:36:41,898 --> 00:36:42,858
让我们看看

677
00:36:45,228 --> 00:36:45,798
不

678
00:36:48,228 --> 00:36:49,158
当然

679
00:36:49,159 --> 00:36:50,298
啊

680
00:36:50,299 --> 00:36:54,558
因为我们把它改成了 main.jsx，这里改一下。

681
00:36:54,559 --> 00:36:55,278
好了

682
00:36:55,279 --> 00:36:56,478
hello 显示了

683
00:36:56,479 --> 00:36:59,508
是 React 渲染的

684
00:36:59,509 --> 00:37:02,478
如你所见 JSX 也是开箱即用的。

685
00:37:02,479 --> 00:37:04,728
你不需要任何配置。

686
00:37:04,729 --> 00:37:14,448
如果你用 tsx 也是一样的。

687
00:37:16,578 --> 00:37:21,108
我们这样导出 App

688
00:37:21,109 --> 00:37:21,918
记住

689
00:37:21,919 --> 00:37:26,058
你需要手动引入 React，因为我们还在用 React 16 版本。

690
00:37:27,618 --> 00:37:29,028
取而代之的是

691
00:37:29,029 --> 00:37:35,948
imports {App} from './App'

692
00:37:36,558 --> 00:37:39,888
它们也一样工作。

693
00:37:41,598 --> 00:37:46,698
所以 typescript , jsx, tsx 都是开箱即用的。

694
00:37:46,699 --> 00:37:49,578
你可以直接导入，它们就能正常工作。

695
00:37:49,579 --> 00:37:50,238
啊

696
00:37:50,239 --> 00:37:53,088
你甚至不需要安装typescript本身

697
00:37:53,089 --> 00:37:59,958
这里的假设是你要做类型检查。

698
00:37:59,959 --> 00:38:05,441
当你开发你的 IDE 能得知一些事情。

699
00:38:05,742 --> 00:38:12,882
你可以添加一个 ts 配置文件，然后 IDE 就可以 lint 你的文件，给到你错误和警告的提示。

700
00:38:12,919 --> 00:38:16,848
Vite 本身并不关心任何类型检查。

701
00:38:16,849 --> 00:38:22,068
它所做的只是将语法转换为浏览器能够理解的 JavaScript。

702
00:38:22,069 --> 00:38:22,458
啊

703
00:38:22,459 --> 00:38:26,358
用 esbuild 就能做到，我们回到开始的地方

704
00:38:26,359 --> 00:38:29,598
我用了 esbuild 两处位置。

705
00:38:29,599 --> 00:38:35,748
第一处使用 esbuild 的地方是它帮我们把 tsx 和 jsx 转为普通的 js 文件。

706
00:38:35,749 --> 00:38:38,898
这里为不知道 esbuild 是什么的观众解释一下，

707
00:38:38,899 --> 00:38:45,288
Esbuild 是用 Go 语言开发的 JavaScript 构建和转义工具。

708
00:38:45,289 --> 00:38:48,708
它被编译成原始的二进制文件

709
00:38:48,709 --> 00:38:51,348
它非常非常快

710
00:38:51,349 --> 00:38:54,228
它是最近才出的吗？

711
00:38:54,229 --> 00:38:55,670
其实已经有一段时间了。

712
00:38:56,839 --> 00:38:57,288
是的

713
00:38:57,289 --> 00:39:00,498
也许它最近才有一些新闻。

714
00:39:00,499 --> 00:39:01,488
是的

715
00:39:01,489 --> 00:39:01,788
我的意思是

716
00:39:01,789 --> 00:39:06,918
Esbuild 之类的项目需要一段时间才能成熟，因为它覆盖了太多的特性，但是...

717
00:39:06,919 --> 00:39:08,298
但里的基本思想是

718
00:39:10,638 --> 00:39:13,068
当你安装 Vite 时就为你安装好了 esbuild。

719
00:39:13,069 --> 00:39:16,938
你不需要安装任何额外工具来对这些文件进行转义。

720
00:39:16,939 --> 00:39:23,118
Esbuild 比传统的 tsc 至少快 20 到 30 倍。

721
00:39:23,118 --> 00:39:30,678
TSC 会花 30-40 毫秒编译 tsx 文件。

722
00:39:30,679 --> 00:39:34,864
但用 esbuild 编译一般只需要 1 毫秒。

723
00:39:36,605 --> 00:39:42,888
Vite 就是利用了 esbuild 这一点，比如一个项目有上百个 ts 文件，

724
00:39:42,889 --> 00:39:45,678
这些加起来就会省很多时间。

725
00:39:45,679 --> 00:39:48,828
用到 esbuild 的另一方面是当我们在里启动 server 时。

726
00:39:48,829 --> 00:39:49,848
注意这里

727
00:39:49,849 --> 00:39:52,368
这里提示检测到新的依赖 react 和 react-dom。

728
00:39:54,438 --> 00:39:59,898
如果你之前用过 creat-react-app 或者 webpack 来开发 React 项目。

729
00:39:59,899 --> 00:40:04,338
你习惯了这样写： import React from 'react'

730
00:40:04,339 --> 00:40:06,198
它就能正常工作。

731
00:40:06,199 --> 00:40:08,778
有时我们甚至会这样做：

732
00:40:08,779 --> 00:40:13,548
像这样命名的导出

733
00:40:13,549 --> 00:40:16,818
但如果你真的去查看 React 到底传递了什么文件。

734
00:40:17,838 --> 00:40:22,707
我们打开 react 文件夹，查看里面的 package.json 文件。

735
00:40:25,279 --> 00:40:27,918
里面写着入口文件是 index.js

736
00:40:27,919 --> 00:40:32,928
在 index.js 里有 module.exports = require 一些东西

737
00:40:32,929 --> 00:40:34,458
这其实是 CommonJS。

738
00:40:34,459 --> 00:40:38,880
React 没有导出原生的 ES 模块，它导出的是 CommonJS 。

739
00:40:40,371 --> 00:40:41,508
导出 CommonJS

740
00:40:41,509 --> 00:40:46,248
但是我们可以像 ES 模块一样引入进来。

741
00:40:46,250 --> 00:40:48,776
很明显在背后中发生了一些事情。

742
00:40:49,348 --> 00:40:53,328
像 webpack、Rollup 都是如此，如果你使用的是 Rollup

743
00:40:53,329 --> 00:40:55,993
你需要 rollup-plugin-commonjs 这个插件

744
00:40:56,387 --> 00:40:59,358
同样 webpack 也在后面做了很多处理。

745
00:40:59,359 --> 00:41:04,398
但如何让 React 在浏览器中运行呢

746
00:41:04,399 --> 00:41:06,618
让我们来看看 Network 标签

747
00:41:09,798 --> 00:41:11,418
啊

748
00:41:11,419 --> 00:41:11,718
啊

749
00:41:11,719 --> 00:41:12,198
上帝

750
00:41:12,199 --> 00:41:12,648
我如何

751
00:41:15,258 --> 00:41:18,618
反正我也找不到这块..

752
00:41:18,619 --> 00:41:21,528
哦，React 在这里。

753
00:41:23,058 --> 00:41:25,878
注意这里的 require_react 。

754
00:41:25,879 --> 00:41:29,838
些代码都是 esbuild 生成的。

755
00:41:29,839 --> 00:41:30,798
所以

756
00:41:32,058 --> 00:41:33,408
当我们重启服务器时

757
00:41:33,409 --> 00:41:34,188
如果我说

758
00:41:36,738 --> 00:41:37,998
vite --force.

759
00:41:39,408 --> 00:41:41,448
这里有 ...

760
00:41:41,582 --> 00:41:43,668
Force 命令是什么意思？

761
00:41:43,669 --> 00:41:44,868
Force 意思是

762
00:41:44,869 --> 00:41:49,248
忽略依赖的缓存，重新处理全部的依赖。

763
00:41:49,249 --> 00:41:50,208
好吧，有意思。

764
00:41:50,209 --> 00:41:50,388
是的

765
00:41:50,389 --> 00:41:52,218
如果你不样做

766
00:41:52,219 --> 00:41:53,328
如果你不样做

767
00:41:53,329 --> 00:41:54,288
它不会

768
00:41:54,289 --> 00:41:55,518
它会检查一些哈希

769
00:41:55,519 --> 00:41:56,658
如果哈希匹配

770
00:41:56,659 --> 00:41:59,478
重新启动服务器时，它不会做任何事情。

771
00:41:59,479 --> 00:42:01,398
但如果你传递了 force 命令，

772
00:42:03,408 --> 00:42:04,638
你只是没有传 force

773
00:42:08,058 --> 00:42:09,708
它会检测到它

774
00:42:09,709 --> 00:42:11,838
Vite 在里的作用是

775
00:42:11,839 --> 00:42:12,918
它会查看你的源码，

776
00:42:12,919 --> 00:42:15,459
注意，你的依赖是 react 和 react-dom。

777
00:42:15,514 --> 00:42:20,958
然后 Vite 会检查 react 和 react-dom 发现它们并不是 ES 模块。

778
00:42:20,959 --> 00:42:23,148
也说我们得对他们做点什么。

779
00:42:23,149 --> 00:42:32,479
所以，我们使用 esbuild 来处理它们，将它们预打包，使他们能够在浏览器中作为原生 ES 模块工作。

780
00:42:32,558 --> 00:42:37,578
我们还有一些智能拦截，以便你可以使用命名导出。

781
00:42:37,579 --> 00:42:41,328
尽管从技术上讲

782
00:42:41,330 --> 00:42:47,328
CommonJS 转换为 ES 模块只有默认的 export。

783
00:42:47,329 --> 00:42:54,738
但我们用一些运行时中断能够让它工作。

784
00:42:54,739 --> 00:42:57,408
这样做的好处有两点。

785
00:42:57,409 --> 00:43:04,098
第一点是将 CommonJS 模块作为原生的 ES 模块运行。

786
00:43:04,099 --> 00:43:09,258
另外一点好处是，比如你使用了像 lodash-es 这样的包。

787
00:43:09,259 --> 00:43:12,048
它内部有 600 多个模块。

788
00:43:12,049 --> 00:43:13,578
当你导入 lodash-es 时，

789
00:43:15,228 --> 00:43:16,398
如果没有任何优化，

790
00:43:16,399 --> 00:43:20,538
浏览器会加载全部 600 多个模块，

791
00:43:20,539 --> 00:43:20,808
所以

792
00:43:20,809 --> 00:43:23,148
如果你在加载时查看 network 选项卡，

793
00:43:24,288 --> 00:43:28,231
我们来添加 lodash-es 依赖

794
00:43:29,088 --> 00:43:35,327
这里写 import _ from 'lodash-es'

795
00:43:38,508 --> 00:43:38,778
好吧

796
00:43:38,779 --> 00:43:43,128
这里并没有很多请求，这是因为我们的服务器，

797
00:43:43,129 --> 00:43:49,308
Vite 服务器智能检测到 lodash-es，并快速将其打包成一个文件。

798
00:43:49,309 --> 00:43:53,088
如果我们不这样做，

799
00:43:53,089 --> 00:43:57,918
你会看到这里有 600 多个请求，这会阻塞浏览器，

800
00:43:57,919 --> 00:43:59,718
尽管它相对较快

801
00:43:59,719 --> 00:44:03,948
但是在处理 Http 请求时，仍然会有很多开销。

802
00:44:03,949 --> 00:44:05,028
理想情况下

803
00:44:05,029 --> 00:44:05,748
即使在 dev 环境

804
00:44:05,749 --> 00:44:07,458
我们仍然希望减少请求的数量

805
00:44:07,459 --> 00:44:16,758
但我们会帮你做了这件事，即使你的依赖内部有上千个模块。

806
00:44:16,759 --> 00:44:23,448
我们还是会用 esbuild 把它们打包成一个文件。

807
00:44:23,449 --> 00:44:26,508
它是如此的快。

808
00:44:26,509 --> 00:44:31,098
不到一秒

809
00:44:31,099 --> 00:44:31,878
但如果你样做了

810
00:44:31,879 --> 00:44:35,478
说明了一些问题

811
00:44:35,479 --> 00:44:36,888
就产生了

812
00:44:36,889 --> 00:44:41,208
因为即使是体积巨大的依赖也是一样快速。

813
00:44:42,798 --> 00:44:47,418
我们键入 yarn add @material-ui/core.

814
00:44:49,728 --> 00:44:52,278
这里将会非常大。

815
00:44:54,018 --> 00:44:56,418
import m from '@material-ui/core'.

816
00:44:59,058 --> 00:45:03,468
我们引入了 material-ui/core。

817
00:45:03,469 --> 00:45:04,158
啊

818
00:45:04,159 --> 00:45:05,958
但只需要不到一秒的时间

819
00:45:05,959 --> 00:45:06,378
理所当然

820
00:45:06,379 --> 00:45:14,598
这是在我的 M1 ARM 架构的 Mac 上运行的，它非常快。

821
00:45:14,599 --> 00:45:15,558
如果你处理这些，

822
00:45:15,559 --> 00:45:19,458
使用 wepack 或者 rollup，一般都需要等待几秒钟。

823
00:45:21,528 --> 00:45:28,097
对于速度这块我测试过一个项目。

824
00:45:28,149 --> 00:45:31,218
使用不同工具速度有明显差异。

825
00:45:31,219 --> 00:45:37,422
这是一个基于 React 和 material-ui 还有其他依赖的真实项目。

826
00:45:38,899 --> 00:45:45,438
我尝试使用 rollup 在我的 M1 Mac 上打包，花了 28 秒钟。

827
00:45:45,498 --> 00:45:48,138
你现在用的就是 M1 Mac 吗？

828
00:45:48,139 --> 00:45:48,648
是的

829
00:45:48,649 --> 00:45:50,088
我在里

830
00:45:50,089 --> 00:45:50,268
是的

831
00:45:50,269 --> 00:45:52,758
你刚才说的那些话

832
00:45:52,759 --> 00:45:53,148
是的

833
00:45:53,149 --> 00:45:58,698
我们用 Vite 来打包，

834
00:45:58,699 --> 00:46:02,088
它只花了 1.5 秒。

835
00:46:02,089 --> 00:46:06,528
启动时间就快了 20 倍。

836
00:46:06,529 --> 00:46:10,278
因为每次你检测到新的导入，

837
00:46:10,279 --> 00:46:11,658
或者添加新的依赖项

838
00:46:11,659 --> 00:46:13,338
缓存会失效，

839
00:46:13,339 --> 00:46:17,328
所以预打包要经常做，

840
00:46:17,329 --> 00:46:23,287
因此用 esbuild 来处理这些简直是救命稻草， 因为样可以节省很多时间。

841
00:46:24,409 --> 00:46:25,278
大多数时候

842
00:46:26,268 --> 00:46:29,748
用 M1 芯片和 esbuild，

843
00:46:29,749 --> 00:46:30,378
我只是

844
00:46:30,379 --> 00:46:35,808
如果启动项目必须等待超过一秒钟，我就会失去耐心。

845
00:46:35,809 --> 00:46:37,038
你是任何一种

846
00:46:37,039 --> 00:46:37,308
是的

847
00:46:37,309 --> 00:46:38,598
说实话，我是被宠坏了。

848
00:46:40,788 --> 00:46:49,638
还需要注意的是 esbuild 目前是基于 Intel 的发布版本。

849
00:46:49,639 --> 00:46:54,678
它还没有支持原生苹果芯片的二进制版本。

850
00:46:54,679 --> 00:46:57,168
我认为最新版本 Go 已经支持了。

851
00:46:57,169 --> 00:47:01,878
但是 esbuild 还没有发布其支持 ARM 架构的二进制版本。

852
00:47:01,878 --> 00:47:07,998
我们实际上是通过 Rosetta 2 运行的 esbuild.

853
00:47:07,999 --> 00:47:11,568
想象一下，它可以再快 20% 到 30%，

854
00:47:11,569 --> 00:47:15,078
一旦我们有了支持 Mac ARM 架构的 esbuild。

855
00:47:17,328 --> 00:47:18,498
所以

856
00:47:18,499 --> 00:47:18,828
是的

857
00:47:18,829 --> 00:47:25,098
这也是 vite 快速的一部分。

858
00:47:25,099 --> 00:47:29,658
当你注意到不同之，当你不仅仅是为了简单的演示项目

859
00:47:29,659 --> 00:47:32,718
当你项目有上百个依赖的项目时

860
00:47:32,719 --> 00:47:41,358
在体验上是有很大不同的。

861
00:47:41,359 --> 00:47:51,258
如果每次你都要等上半分钟或者一分钟，我就很不想做这个项目了。

862
00:47:52,368 --> 00:47:52,668
是的。

863
00:47:53,748 --> 00:47:56,658
这也有助于我调试，

864
00:47:56,659 --> 00:47:57,048
因为现在

865
00:47:57,049 --> 00:47:59,418
就像每次有人向我反馈新的问题，

866
00:47:59,419 --> 00:48:01,548
我把仓库 clone 下来，

867
00:48:01,549 --> 00:48:03,138
然后几乎是马上就能启动了。

868
00:48:03,139 --> 00:48:04,998
我不需要等

869
00:48:04,999 --> 00:48:09,198
因此，调试 Vite 本身也变得更加令人愉快。

870
00:48:10,998 --> 00:48:11,268
是的

871
00:48:11,269 --> 00:48:11,508
我的意思是

872
00:48:11,509 --> 00:48:17,688
我有一些需要调试的项目，我的很多常规网站实际上需要你花很多时间来启动。

873
00:48:17,689 --> 00:48:20,298
我不会想删除任何框架

874
00:48:20,299 --> 00:48:22,278
但它也有一些问题。

875
00:48:22,279 --> 00:48:25,278
在聊天室有一些问题。

876
00:48:25,279 --> 00:48:28,368
我们的生产情况怎么样，vite 可以用在生产环境吗？

877
00:48:28,369 --> 00:48:32,028
我知道现在 vite 仓库里有一个 flag 是 2.0 的 beta 版本。

878
00:48:33,978 --> 00:48:41,221
在过去的几周我们已经开始稳定下来了，没有特别大的缺陷遗留。

879
00:48:41,221 --> 00:48:49,998
如果你有一些特别棘手的依赖关系，那么还有一些小的边缘情况：比如 CommonJS 中混合了 ES 模块。

880
00:48:49,999 --> 00:48:52,578
会有一些小问题

881
00:48:52,579 --> 00:48:59,838
但大多数情况下没问题，我们每周有接近三万多的下载量。

882
00:49:01,818 --> 00:49:04,308
最新几个版本相当稳定。

883
00:49:04,309 --> 00:49:06,798
我认为我们很快就会推出正式版。

884
00:49:11,163 --> 00:49:18,348
我们接着来看生产模式。如果你想转向生产，

885
00:49:18,349 --> 00:49:19,968
让我们在这里添加脚本。

886
00:49:22,218 --> 00:49:24,168
build: 'vite build'

887
00:49:26,838 --> 00:49:29,568
这就是字面上的意思

888
00:49:29,569 --> 00:49:35,988
你执行 yarn run build。你在 dev 环境能够正常运行的话，

889
00:49:35,989 --> 00:49:37,578
从理论上讲

890
00:49:37,579 --> 00:49:42,498
我们保证我们保证它在生产环境也能运行。

891
00:49:42,499 --> 00:49:44,688
如果不符合预期，

892
00:49:44,689 --> 00:49:45,738
那么这就是漏洞了，

893
00:49:45,739 --> 00:49:46,398
我们会解决它

894
00:49:46,399 --> 00:49:51,708
但基本的想法是，

895
00:49:53,688 --> 00:49:55,638
我们建造了它

896
00:49:55,639 --> 00:49:59,418
我们也有一个 Vite 命令：

897
00:50:01,188 --> 00:50:02,118
vite preview

898
00:50:04,938 --> 00:50:09,258
这会启动服务器，运行我们刚打包创建的文件。

899
00:50:09,259 --> 00:50:14,448
也就是 dist 目录，它会运行生产包。

900
00:50:14,449 --> 00:50:17,268
这是生产版本。

901
00:50:17,269 --> 00:50:21,738
我们在生产环节上做了很多有趣的事情

902
00:50:21,739 --> 00:50:24,108
在我们文档的 Feature 部分，

903
00:50:24,109 --> 00:50:30,348
里面有专门的构建优化章节，

904
00:50:30,349 --> 00:50:31,698
构建目标

905
00:50:31,699 --> 00:50:37,968
Vite 默认的构建目标是支持原生 ES 模块的浏览器。

906
00:50:37,969 --> 00:50:40,518
默认情况下，它不支持 IE 11。

907
00:50:40,519 --> 00:50:42,828
这点需要注意。

908
00:50:42,829 --> 00:50:44,628
Vite 默认支持现代浏览器。

909
00:50:44,629 --> 00:50:47,598
但是我们也有支持旧浏览器的选项。

910
00:50:47,599 --> 00:50:49,878
我一会儿会讲到。

911
00:50:49,879 --> 00:51:00,648
但如果你的目标是现代浏览器。显然你不需要做非常耗时的 Babel 预设转义，这样会更快。

912
00:51:00,649 --> 00:51:06,198
我们自动 polyfill 了动态导入功能。

913
00:51:06,199 --> 00:51:13,368
实际上，原生的 ES 模块和原生的 ES 动态导入模块有支持差异。

914
00:51:13,369 --> 00:51:15,168
我们将其 polyfill 了。

915
00:51:15,169 --> 00:51:18,429
我们还有 CSS 代码分割。

916
00:51:18,429 --> 00:51:25,038
在 vite 项目中，所有的代码分割都可以通过动态 ES 模块导入来解决。

917
00:51:26,628 --> 00:51:27,078
我们

918
00:51:27,079 --> 00:51:30,168
因为我们将 CSS 也视为模块图的一部分。

919
00:51:30,169 --> 00:51:32,238
我们可以对 CSS 做代码分割。

920
00:51:32,239 --> 00:51:34,488
如果是异步的包，

921
00:51:34,489 --> 00:51:35,628
懒加载的路由，

922
00:51:35,629 --> 00:51:42,918
所有被懒加载路由导入的 CSS 都被分割成单独的文件。

923
00:51:42,919 --> 00:51:44,268
当这个包被请求时，

924
00:51:44,269 --> 00:51:47,838
我们并行地获取 JavaScript 和 CSS 文件。

925
00:51:47,839 --> 00:51:48,138
是的

926
00:51:48,139 --> 00:51:53,898
确保 JavaScript 模块被解析之前完成 CSS 加载。

927
00:51:53,899 --> 00:51:58,248
这样就不会出现"无样式内容闪烁"（FOUC）的问题了。

928
00:51:58,249 --> 00:52:00,648
这些功能都是开箱即用的。

929
00:52:00,649 --> 00:52:06,198
你不需要配置任何东西。如果用 webpack 实现相同功能，

930
00:52:06,199 --> 00:52:07,728
那就是另一段故事了。

931
00:52:07,729 --> 00:52:09,408
你需要查看 CSS，

932
00:52:09,409 --> 00:52:11,358
很多 CSS 是带日志的。

933
00:52:12,768 --> 00:52:15,918
有个问题已经提过很多次了

934
00:52:15,919 --> 00:52:17,238
我不确定是否相关

935
00:52:17,239 --> 00:52:21,468
Vite 支持 SSR 吗？

936
00:52:21,469 --> 00:52:24,408
我想讲讲 Vite 的服务端渲染比较好。

937
00:52:25,608 --> 00:52:29,118
嗯，Vite 的 SSR 目前是实验性的。

938
00:52:29,119 --> 00:52:30,198
啊

939
00:52:30,199 --> 00:52:31,158
是的

940
00:52:31,159 --> 00:52:32,118
我可以知道

941
00:52:33,048 --> 00:52:39,738
从零开始设置有点复杂，这里的思想是，

942
00:52:39,739 --> 00:52:41,418
但是这里的思想是

943
00:52:42,648 --> 00:52:49,398
让我们退后一步，我们需要 SSR 做什么，我们需要打包工具打出的代码能够运行在服务端。

944
00:52:49,399 --> 00:52:49,998
我们的想法是

945
00:52:49,999 --> 00:52:53,388
你想让你的代码在 nodejs 里运行

946
00:52:53,389 --> 00:52:55,908
但我们正在写

947
00:52:55,909 --> 00:52:57,888
我们编写代码

948
00:52:57,889 --> 00:53:00,558
但是我们使用了 ES 模块

949
00:53:01,698 --> 00:53:07,188
如果你使用的不是 nodejs 的最新版本，

950
00:53:07,189 --> 00:53:11,868
nodejs 的最新版本支持原生 ES 模块。

951
00:53:11,869 --> 00:53:18,339
这段代码不能正常运行，因为以前的 nodejs 版本需要 CommonJS。

952
00:53:18,339 --> 00:53:25,878
而我们在里所做的是提供可编程 API ssrLoadModule。

953
00:53:25,879 --> 00:53:34,848
我们受到了里奇·哈里斯在 Svelte 工作的想法的启发。

954
00:53:35,718 --> 00:53:40,428
可以在现有的 nodejs 服务器中使用 vite 作为中间件。

955
00:53:40,429 --> 00:53:41,508
如果你这么做，

956
00:53:41,509 --> 00:53:44,988
你想自己控制服务器，这样你就可以，

957
00:53:44,989 --> 00:53:48,858
比如 express 服务器运行 vite 作为它内部的中间件。

958
00:53:50,028 --> 00:53:55,878
使用称 vite.ssrLoadModule 来加载我们的模块。

959
00:53:58,848 --> 00:54:03,828
像这样加载 entry-server.js 文件。

960
00:54:04,758 --> 00:54:06,048
差不多了。

961
00:54:06,049 --> 00:54:14,058
你的服务器入口在 nodejs 中运行，它可以使用相同的 ES 模块导入语法来加载应用的剩余部分。

962
00:54:14,059 --> 00:54:17,778
显然你需要确保你的代码是兼容 nodejs 的。

963
00:54:17,779 --> 00:54:28,038
但是你可以使用 ES 模型语法，而 vite 会动态地把些语法快速转换成兼容 CommonJS 的语法。

964
00:54:28,039 --> 00:54:30,498
这样它就能真正运行在 nodejs 环境了。

965
00:54:32,148 --> 00:54:33,978
我们通常在 webpack 里的做法是，

966
00:54:33,979 --> 00:54:35,448
根据源程序设置

967
00:54:35,449 --> 00:54:40,848
我们在开发过程将应用全部打包，

968
00:54:40,849 --> 00:54:47,898
因此 它使用webpack将您的整个应用程序打包，并将其作为 CommonJS 导出，以便在 nodejs 环境中运行。

969
00:54:47,899 --> 00:54:51,618
但是这样缺点很明显，每次当你编辑文件时，

970
00:54:51,619 --> 00:54:57,078
你要把整个应用打包

971
00:54:57,079 --> 00:55:05,418
这样会很慢。当你用 vite 时，这些模块都是单独缓存的。

972
00:55:05,419 --> 00:55:07,338
就像在浏览器里，对吧

973
00:55:07,339 --> 00:55:12,738
我们利用原生 ES 模块的原因之一是每个模型都能够单独缓存。

974
00:55:12,739 --> 00:55:15,108
我们做模块热更新，

975
00:55:15,109 --> 00:55:19,638
在这里只会使正在编辑的模型失效，

976
00:55:19,639 --> 00:55:20,328
同样的

977
00:55:20,329 --> 00:55:22,638
对于服务端渲染也一样。

978
00:55:22,639 --> 00:55:31,128
我们为 ssr 实例化缓存所模块为，使用在内部模块图中。

979
00:55:31,129 --> 00:55:32,568
当你编辑文件时

980
00:55:32,569 --> 00:55:36,798
我们只会将正在编辑的模块失效。

981
00:55:36,799 --> 00:55:42,588
你可以把它看作是开发时的 SSR 模块热更新。

982
00:55:42,589 --> 00:55:45,078
不需要整体重新打包。

983
00:55:45,079 --> 00:55:52,788
另外 Vite 也会智能识别 CommonJS 的模块。

984
00:55:52,789 --> 00:55:54,258
例如

985
00:55:54,259 --> 00:55:59,208
如果你用 Vue 或者 React，比如你用 React，React 已经是 CommonJS 了

986
00:55:59,209 --> 00:56:00,138
如果你用

987
00:56:00,139 --> 00:56:01,548
React 在 SSR 中。

988
00:56:01,549 --> 00:56:02,418
你只需要 require，

989
00:56:02,419 --> 00:56:14,418
不需要打包编译，因为没有必要， React 已经是 CommonJS 了，vite 检测全部依赖，并自动外部化它们。

990
00:56:14,419 --> 00:56:17,058
当你使用 import React 时，

991
00:56:17,059 --> 00:56:18,078
它实际上只是在调用

992
00:56:18,079 --> 00:56:22,758
require react ，这样你就不用付出额外的打包编译成本。

993
00:56:23,808 --> 00:56:26,838
就像处理 React 作为包的一部分一样

994
00:56:26,839 --> 00:56:30,558
每改变都是自动完成的

995
00:56:30,559 --> 00:56:33,168
这里有关于 SSR 的进一步指引。

996
00:56:35,178 --> 00:56:37,278
如果你去我们的 GitHub 仓库，

997
00:56:37,279 --> 00:56:39,798
实际上，我们还有

998
00:56:39,799 --> 00:56:41,358
我可以在里。。。

999
00:56:43,788 --> 00:56:48,708
你刚才解释的和增量构建是类似的吗？

1000
00:56:50,388 --> 00:56:52,308
它与增量构建不同

1001
00:56:52,309 --> 00:56:58,998
增量构建仍然是全的，因为增量构建要困难得多

1002
00:56:58,999 --> 00:57:01,398
我们刚才说的主要集中在开发体验上

1003
00:57:01,399 --> 00:57:02,928
比如你在开发的时候。

1004
00:57:02,929 --> 00:57:03,168
好吧

1005
00:57:03,169 --> 00:57:03,948
明白了

1006
00:57:03,949 --> 00:57:04,368
是的

1007
00:57:04,369 --> 00:57:06,078
我们看一下时间。

1008
00:57:06,079 --> 00:57:09,048
我们只预约了 1 个小时。

1009
00:57:09,049 --> 00:57:10,068
但是好吧

1010
00:57:10,069 --> 00:57:11,988
如果你想继续，我们可以继续

1011
00:57:11,989 --> 00:57:14,118
如果你想把想法都讲完。

1012
00:57:14,119 --> 00:57:22,638
到目前为止我们都收获了很多。

1013
00:57:22,639 --> 00:57:23,178
所以

1014
00:57:23,179 --> 00:57:23,478
是的

1015
00:57:23,479 --> 00:57:26,148
如果你对 SSR 感兴趣。

1016
00:57:26,149 --> 00:57:27,918
来看我们的 GitHub 仓库。

1017
00:57:27,919 --> 00:57:32,478
我们在源码中有非常全面的 playground 目录。

1018
00:57:32,479 --> 00:57:38,418
它有所有主要功能的演示环境。

1019
00:57:38,419 --> 00:57:46,128
是两个完全有效的 SSR 例子，分别是 Vue 和 React 的。

1020
00:57:46,129 --> 00:57:48,918
如果你想尝试一下

1021
00:57:48,919 --> 00:57:51,018
可以用这些作为参考

1022
00:57:53,568 --> 00:57:54,138
很好。

1023
00:57:55,728 --> 00:57:55,998
好吧

1024
00:57:55,999 --> 00:57:57,588
在所有些想法中

1025
00:57:57,589 --> 00:58:03,348
到目前为止，模块热更新我还没有讲到。

1026
00:58:03,349 --> 00:58:03,798
所以

1027
00:58:05,448 --> 00:58:11,898
我来新建一个项目，cvs 是 create-vite-app 的本地别名。

1028
00:58:11,899 --> 00:58:12,678
啊

1029
00:58:14,238 --> 00:58:16,818
每个 demo 我重新创建，

1030
00:58:16,819 --> 00:58:20,958
使用 vite init

1031
00:58:22,278 --> 00:58:26,748
也是你看到的这样，它会运行。

1032
00:58:26,749 --> 00:58:29,748
vite 已经快速创建了应用。

1033
00:58:29,749 --> 00:58:34,098
你可以从这些现有模板中选择需要的模板。

1034
00:58:34,099 --> 00:58:37,848
我这里选择基础的 Vue 模板。

1035
00:58:40,128 --> 00:58:41,538
进到 vite-vue-demo 文件夹。

1036
00:58:43,158 --> 00:58:45,408
我只使用本地链接

1037
00:58:45,409 --> 00:58:46,218
提要

1038
00:58:46,219 --> 00:58:47,808
安装的依赖。

1039
00:58:49,128 --> 00:58:51,168
我得到了

1040
00:58:51,169 --> 00:58:51,588
是

1041
00:58:53,538 --> 00:58:55,758
在 Vite 上运行的 Vue 3 应用。

1042
00:58:59,058 --> 00:59:01,548
我用 VS Code 打开它。

1043
00:59:06,678 --> 00:59:10,338
如果你以前用过 Vue CLI，你会发现生成的文件结构很相似。

1044
00:59:10,339 --> 00:59:14,928
感觉和 Vue CLI 生成的一样。

1045
00:59:14,929 --> 00:59:18,018
很明显，如果我编辑一些东西

1046
00:59:18,019 --> 00:59:18,978
我要去

1047
00:59:19,968 --> 00:59:20,808
点击计数器

1048
00:59:21,768 --> 00:59:25,488
只是为了说明 HTML 实际上没有闪烁。

1049
00:59:30,948 --> 00:59:32,898
Html 真的是

1050
00:59:32,899 --> 00:59:33,888
非常快

1051
00:59:33,889 --> 00:59:36,438
这里的想法是

1052
00:59:36,439 --> 00:59:39,558
如果你正在开发大型应用程序

1053
00:59:39,559 --> 00:59:43,758
每次编辑都重新加载页面显然不是最优的

1054
00:59:43,759 --> 00:59:48,108
特别是你有一些页面状态

1055
00:59:48,109 --> 00:59:54,828
我想看看下拉菜单或者调整样式和逻辑的时候。

1056
00:59:54,829 --> 01:00:00,198
如果重新加载整个应用，那每次都需要重新打开下拉列表

1057
01:00:00,199 --> 01:00:03,768
模块热更新就不是这样了。

1058
01:00:03,769 --> 01:00:05,628
我相信是那种，

1059
01:00:06,828 --> 01:00:08,208
如果

1060
01:00:08,209 --> 01:00:14,748
应用大小与反馈速度有关。

1061
01:00:14,749 --> 01:00:18,858
就像让事情变得更快的想法

1062
01:00:18,859 --> 01:00:21,678
因为就我个人而言，作为开发者

1063
01:00:21,679 --> 01:00:22,908
每当我在工作的时候

1064
01:00:22,909 --> 01:00:25,518
如果我知道件事需要很长时间

1065
01:00:25,519 --> 01:00:27,048
我不愿意做件事

1066
01:00:28,188 --> 01:00:33,978
他会降低你工作的热情。

1067
01:00:33,979 --> 01:00:36,588
会让你更不喜欢你的工作

1068
01:00:36,589 --> 01:00:39,408
如果一切都很快，

1069
01:00:39,409 --> 01:00:49,788
那么你会更开心，更有效率。 我认为想让开发者更开心，就让他们使用的工具更快一些吧。

1070
01:00:51,858 --> 01:00:56,478
这就是整个前提

1071
01:00:56,479 --> 01:00:57,858
如果我们从更高的层面来看

1072
01:00:57,859 --> 01:01:01,608
看看 vite 在这里要做的事情。

1073
01:01:01,609 --> 01:01:04,248
为不直接用 esbuild 来处理全部呢？

1074
01:01:04,249 --> 01:01:06,198
如果它么快

1075
01:01:06,199 --> 01:01:07,908
事情是

1076
01:01:07,909 --> 01:01:10,098
即使 esbuild 非常快

1077
01:01:10,099 --> 01:01:16,308
你肯定不希望在每一次编辑时都重新打包全部内容

1078
01:01:16,309 --> 01:01:17,688
因为即使它是快速的

1079
01:01:17,689 --> 01:01:22,068
它会随着应用大小的增长变得越来越慢。

1080
01:01:22,069 --> 01:01:22,668
我们的想法是

1081
01:01:22,669 --> 01:01:26,358
我想让你把增加的反馈和总规模结合起来

1082
01:01:26,359 --> 01:01:27,618
你的应用

1083
01:01:27,619 --> 01:01:30,228
为什么我们需要模块热更新，

1084
01:01:30,229 --> 01:01:35,628
但我们过去遇到的挑战是，

1085
01:01:35,629 --> 01:01:37,158
使用 webpack 的时候，

1086
01:01:37,159 --> 01:01:38,358
我不知道为什么

1087
01:01:38,359 --> 01:01:40,188
但在实践中

1088
01:01:40,189 --> 01:01:47,508
我们已经注意到 webpack 的模块热更新性能随着应用大小增长极速下降。

1089
01:01:47,509 --> 01:01:48,498
从技术上讲

1090
01:01:48,499 --> 01:01:50,238
我的意思是理论上它不应该这样。

1091
01:01:50,239 --> 01:01:54,348
但在很大程度上这就是正在发生的事情。

1092
01:01:54,349 --> 01:01:56,178
使用 webpack 的应用

1093
01:01:56,179 --> 01:02:02,298
即使是用了模块热更新，通常需要等待几秒页面才会最终会更新。

1094
01:02:02,300 --> 01:02:09,918
但 vite 利用了原生的 ES 模块来做模块热更新。

1095
01:02:10,099 --> 01:02:15,078
前提是现在每个模块都是单独缓存的

1096
01:02:15,079 --> 01:02:16,158
当你编辑文件时

1097
01:02:16,159 --> 01:02:23,958
我们只需为它们特定的模块和链使其缓存无效。

1098
01:02:23,959 --> 01:02:32,868
一条导入链可以重新引入模块。

1099
01:02:32,869 --> 01:02:34,518
说

1100
01:02:34,519 --> 01:02:36,198
当你编辑一些 Vue 文件时

1101
01:02:36,199 --> 01:02:37,638
这个文件是唯一失效的。

1102
01:02:37,639 --> 01:02:38,628
它是

1103
01:02:38,629 --> 01:02:40,938
是该文件本身。

1104
01:02:40,939 --> 01:02:45,948
我们并没有将整个应用重新构建。

1105
01:02:45,949 --> 01:02:48,198
这样我们就可以重新载入页面了

1106
01:02:48,199 --> 01:02:49,308
没有比

1107
01:02:49,309 --> 01:02:52,398
我们就会看到

1108
01:02:52,399 --> 01:02:52,998
事实上

1109
01:02:52,999 --> 01:02:54,768
如果我们看一下network选项卡

1110
01:03:01,728 --> 01:03:02,148
上帝

1111
01:03:02,149 --> 01:03:02,868
是也

1112
01:03:05,838 --> 01:03:08,748
我可以清除吗，不

1113
01:03:08,749 --> 01:03:09,318
这一个

1114
01:03:09,319 --> 01:03:10,788
对我来说是未知的领域

1115
01:03:10,789 --> 01:03:13,068
我从未见过如此活跃的网络标签

1116
01:03:14,508 --> 01:03:14,838
是的

1117
01:03:14,839 --> 01:03:15,978
好吧

1118
01:03:15,979 --> 01:03:18,978
我觉得很酷的一点是所有的东西都是单独导入的

1119
01:03:18,979 --> 01:03:21,228
在这里

1120
01:03:23,329 --> 01:03:24,198
啊

1121
01:03:24,199 --> 01:03:25,518
好吧

1122
01:03:25,519 --> 01:03:26,058
这一个

1123
01:03:26,059 --> 01:03:30,768
这是我们每次编辑后生成的唯一一个新的请求。

1124
01:03:30,769 --> 01:03:35,178
我们只是取回特定文件的更新版本

1125
01:03:35,179 --> 01:03:43,488
我们精确地应用更新，这样就不会重新加载整个应用。

1126
01:03:43,489 --> 01:03:47,268
我们不需要做任何打包的工作。

1127
01:03:47,269 --> 01:03:50,328
它已经非常精确了。

1128
01:03:50,329 --> 01:03:52,458
就像你提到的 tree shaking。

1129
01:03:55,368 --> 01:04:00,498
Vite 会将不使用的代码拿掉吗？

1130
01:04:00,499 --> 01:04:10,038
Tree shaking 更多是生产环境使用的，我们在开发环境不用担心请求额外的几 KB。

1131
01:04:12,828 --> 01:04:13,488
在生产中

1132
01:04:13,489 --> 01:04:14,958
你需要使用 tree shaking。

1133
01:04:14,959 --> 01:04:20,504
这是打包器做的事情，vite 也使用了打包器。

1134
01:04:20,504 --> 01:04:26,028
Vite 的打包器是基于 Rollup 的。

1135
01:04:26,029 --> 01:04:27,498
事实上

1136
01:04:27,499 --> 01:04:31,248
Vite 的插件是 Rollup 插件的超集。

1137
01:04:31,249 --> 01:04:34,068
如果你知道如何写 Rollup 插件，

1138
01:04:34,069 --> 01:04:36,108
那么你就会写 Vite 插件了。

1139
01:04:36,109 --> 01:04:42,078
Vite 的很多概念，如 resolveid，transform load

1140
01:04:42,079 --> 01:04:45,408
都和 Rollup 一样。

1141
01:04:45,409 --> 01:04:49,488
Vite 扩展了 Rollup 接口，并提供了几个

1142
01:04:52,218 --> 01:04:56,058
Vite 专属的属性和钩子。

1143
01:04:56,059 --> 01:04:57,828
为了更简单

1144
01:04:59,538 --> 01:05:03,168
我想讲的差不多了

1145
01:05:03,169 --> 01:05:04,608
我不知道这是否能够帮助到大家。

1146
01:05:04,609 --> 01:05:09,498
我想谈谈我们已经讨论过内置的框架支持。

1147
01:05:09,499 --> 01:05:17,058
我知道有一群用户在研究 vite 和 svelte 的整合。

1148
01:05:17,059 --> 01:05:17,748
事实上

1149
01:05:19,128 --> 01:05:25,518
我发现一个 rollup 插件很有用，就 fork 它用在 vite 上。

1150
01:05:25,519 --> 01:05:28,758
刚才有观众提到了 Rollup 的问题。

1151
01:05:28,759 --> 01:05:30,828
为什么不在生产环境也用 esbuild 呢？

1152
01:05:31,908 --> 01:05:37,458
Esbuild 用在生产环境还存在一些问题。

1153
01:05:38,899 --> 01:05:46,548
基本上 esbuild 对打包功能的支持不够完整。

1154
01:05:46,549 --> 01:05:47,568
我想说

1155
01:05:47,569 --> 01:05:49,488
我想在未来

1156
01:05:49,489 --> 01:05:53,478
当 esbuild 的打包功能更稳定

1157
01:05:53,479 --> 01:05:55,128
我们知道是

1158
01:05:55,129 --> 01:06:00,918
那么我们就会使用它，毕竟我们一直在使用它。

1159
01:06:00,919 --> 01:06:02,028
问题是

1160
01:06:02,029 --> 01:06:02,718
例如

1161
01:06:02,719 --> 01:06:07,365
你想对数据包渲染有更多的控制

1162
01:06:07,365 --> 01:06:15,858
在生成哈希值，处理附件，提交文件等问题上

1163
01:06:15,859 --> 01:06:18,318
对打包内容进行分析优化

1164
01:06:18,319 --> 01:06:22,386
所有这些你熟悉的东西，

1165
01:06:22,386 --> 01:06:26,808
现在都没法使用 esbuild 来处理。

1166
01:06:26,809 --> 01:06:29,118
目前是这样。

1167
01:06:29,119 --> 01:06:29,868
我知道

1168
01:06:29,869 --> 01:06:36,288
亚伦·沃利斯说他计划写 eabuild 处理代码分割。

1169
01:06:36,289 --> 01:06:39,468
我们不依赖它的原因

1170
01:06:39,469 --> 01:06:39,768
我的意思是

1171
01:06:39,769 --> 01:06:42,528
在打包应用层面，

1172
01:06:42,529 --> 01:06:44,508
Rollup 还是更合适的。

1173
01:06:44,509 --> 01:06:44,748
我的意思是

1174
01:06:44,749 --> 01:06:49,368
我们选择打包更稳定的 Rollup。

1175
01:06:49,369 --> 01:06:55,818
很明显，不使用 esbuild 打包也意味着打包要慢很多

1176
01:06:55,819 --> 01:06:58,188
我们一直用 esbuild 就很快。

1177
01:06:58,189 --> 01:07:07,068
但好处是你会得到更健壮更高效的生产包。

1178
01:07:07,069 --> 01:07:10,698
你可以做的一件事是你可以用 esbuild 来压缩文件。

1179
01:07:10,699 --> 01:07:12,348
默认压缩器使用的是 terser。

1180
01:07:12,349 --> 01:07:14,208
但是你可以这样 vite build -- minify esbuild

1181
01:07:17,089 --> 01:07:17,508
啊

1182
01:07:17,509 --> 01:07:22,398
我们可以用 esbuild 作为压缩器，这样会大大加快构建的速度。

1183
01:07:22,399 --> 01:07:26,898
但在大多数情况下，包会稍微大一些

1184
01:07:26,899 --> 01:07:28,968
你需要做出权衡。

1185
01:07:28,969 --> 01:07:30,318
想一想

1186
01:07:30,319 --> 01:07:31,188
你愿意交换吗

1187
01:07:31,189 --> 01:07:35,628
也许大百分之五到十的额外大小来换取更快的打包速度。

1188
01:07:35,629 --> 01:07:36,288
由你决定

1189
01:07:37,488 --> 01:07:38,448
好吧

1190
01:07:38,449 --> 01:07:39,768
优秀的

1191
01:07:39,769 --> 01:07:40,098
是的

1192
01:07:40,099 --> 01:07:47,478
我想最后问题是人们如何跟上 vite 的进度。

1193
01:07:47,479 --> 01:07:51,906
我知道你们已经有很多贡献者了。

1194
01:07:51,906 --> 01:07:54,738
是的，我们有很多贡献者了。

1195
01:07:54,738 --> 01:08:03,648
最简单的保持联系的方法是去Twitter，vite_js 就是我们的账号。

1196
01:08:03,649 --> 01:08:05,778
不幸的是

1197
01:08:05,779 --> 01:08:10,998
没有下划线的版本已经存在了

1198
01:08:10,999 --> 01:08:11,988
是的

1199
01:08:11,989 --> 01:08:19,968
Vite 已经有了很多贡献者，大家可以来寻求帮助。

1200
01:08:19,969 --> 01:08:20,238
哦

1201
01:08:20,239 --> 01:08:23,898
我们还有一个 chat.vitejs.dev

1202
01:08:23,899 --> 01:08:25,188
那是我们的 Discord 社区

1203
01:08:25,189 --> 01:08:27,738
如果你以后想加入

1204
01:08:27,739 --> 01:08:31,698
我不知道 Discord 还能配置这样的域名。

1205
01:08:32,928 --> 01:08:35,208
这是我们的网址重定向。

1206
01:08:35,209 --> 01:08:37,038
好吧

1207
01:08:37,039 --> 01:08:37,848
好吧

1208
01:08:37,849 --> 01:08:38,718
是的

1209
01:08:38,719 --> 01:08:42,768
chat.vitejs.dev

1210
01:08:42,769 --> 01:08:45,348
你会自动被邀请进入我们的 Discord 社区。

1211
01:08:45,349 --> 01:08:48,588
这里有很酷。

1212
01:08:50,898 --> 01:08:51,258
是的

1213
01:08:51,259 --> 01:08:53,688
差不多了

1214
01:08:53,689 --> 01:08:53,988
是的

1215
01:08:53,989 --> 01:08:54,228
好吧

1216
01:08:54,229 --> 01:08:56,718
非常感谢尤雨溪带来的直播，

1217
01:08:56,719 --> 01:08:57,738
我觉得真的很好

1218
01:08:58,399 --> 01:09:03,378
我希望你一定会注意到那些直播游戏的人

1219
01:09:03,379 --> 01:09:04,548
如果你喜欢

1220
01:09:04,549 --> 01:09:06,378
你可以找到 Evan

1221
01:09:06,379 --> 01:09:08,268
他有推特或抱歉

1222
01:09:08,269 --> 01:09:08,838
是有 Twitter

1223
01:09:08,839 --> 01:09:10,758
但是他也有 Twitch

1224
01:09:10,759 --> 01:09:13,548
你的 Twitch 用户名和 Twitter 一样吗

1225
01:09:13,549 --> 01:09:16,578
和屏幕上的是一样的吗

1226
01:09:16,579 --> 01:09:19,008
是一样的

1227
01:09:19,009 --> 01:09:19,308
好吧

1228
01:09:19,309 --> 01:09:22,758
大家都要关注 Twitch 确保他每次直播的时候，

1229
01:09:22,759 --> 01:09:24,558
在展示一些代码时候，

1230
01:09:24,559 --> 01:09:25,998
不会错过。

1231
01:09:25,999 --> 01:09:29,508
如果你有兴趣了解更多的项目

1232
01:09:29,509 --> 01:09:33,768
关注 Open Source Friday，我们会有通知。

1233
01:09:33,769 --> 01:09:35,748
我也会做直播

1234
01:09:35,749 --> 01:09:38,448
我的名字就在下面，我是 bdougieYO。

1235
01:09:38,449 --> 01:09:40,158
我做了很多 GitHub Actions 的工作

1236
01:09:40,159 --> 01:09:43,248
我还没展示这个T恤。

1237
01:09:43,249 --> 01:09:46,158
这是给你们准备的

1238
01:09:46,159 --> 01:09:47,928
趁着还有货赶紧买

1239
01:09:47,929 --> 01:09:49,488
与此同时

1240
01:09:49,489 --> 01:09:52,068
我想我们结束直播了，

1241
01:09:52,069 --> 01:09:53,478
谢谢大家

1242
01:09:55,218 --> 01:09:55,668
谢谢。

