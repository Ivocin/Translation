﻿1
00:00:04,000 --> 00:00:10,550
嗨。我的名字是 Dan。我在 React

2
00:00:10,550 --> 00:00:13,759
Team 工作，这是我第一次参加 React

3
00:00:13,759 --> 00:00:28,160
大会。 [掌声] 刚才 Sophie 讲述了这三个

4
00:00:28,160 --> 00:00:30,740
问题，我想大多数的开发者在 React

5
00:00:30,740 --> 00:00:34,280
开发过程中都会遇到这些问题。当然，

6
00:00:34,280 --> 00:00:35,629
我们可以逐一来解决

7
00:00:35,629 --> 00:00:38,509
这些问题。我们可以尝试独立地去

8
00:00:38,509 --> 00:00:41,840
解决这些问题。但是实际上解决其中一个问题

9
00:00:41,840 --> 00:00:44,829
可能会使其他问题更加严重。

10
00:00:44,829 --> 00:00:48,199
比如我们尝试去解决

11
00:00:48,199 --> 00:00:51,079
“包装地狱”的问题，可以将更多的逻辑放到

12
00:00:51,079 --> 00:00:53,780
组件里面，那么我们的

13
00:00:53,780 --> 00:00:55,879
组件会变得更大，而且更难以

14
00:00:55,879 --> 00:00:58,879
重构。另一个方面，如果

15
00:00:58,879 --> 00:01:01,910
我们尝试将组件拆分为

16
00:01:01,910 --> 00:01:06,019
更小的片段，以方便重用，那么

17
00:01:06,019 --> 00:01:07,550
我们的组件树的嵌套更多了，

18
00:01:07,550 --> 00:01:09,139
而且最终又会以

19
00:01:09,139 --> 00:01:13,519
“包装地狱” 收场。最后，无论那种情况，

20
00:01:13,519 --> 00:01:15,499
使用 class 都会让人产生

21
00:01:15,499 --> 00:01:18,230
困惑。因此我们认为造成这种情况是因为

22
00:01:18,230 --> 00:01:19,910
这不是三个独立的

23
00:01:19,910 --> 00:01:23,660
问题。我们认为，这是同一个问题的

24
00:01:23,660 --> 00:01:27,470
三个症状。问题在于

25
00:01:27,470 --> 00:01:29,749
React 没有原生提供一个比 class 组件更

26
00:01:29,749 --> 00:01:34,850
简单，更小型，更轻量级的方式来

27
00:01:34,850 --> 00:01:37,670
添加 state 或生命周期。

28
00:01:37,670 --> 00:01:41,360
而且一旦你使用了 class

29
00:01:41,360 --> 00:01:44,420
组件，你没有办法在不造成“包装地狱”的情况下,

30
00:01:44,420 --> 00:01:48,190
进一步拆分它。事实上，

31
00:01:48,190 --> 00:01:51,889
这并不是一个新问题。如果你

32
00:01:51,889 --> 00:01:54,530
已经使用了 React 几年，

33
00:01:54,530 --> 00:01:57,050
你也许还记得在 React

34
00:01:57,050 --> 00:01:59,329
刚出来的时候，事实上已经包含了一个解决

35
00:01:59,329 --> 00:02:03,110
方案。嗯，这个解决方案就是 mixins。

36
00:02:03,110 --> 00:02:06,499
Mixins 能够让你在 class 之间复用

37
00:02:06,499 --> 00:02:08,060
方法，通过 mixins 可以

38
00:02:08,060 --> 00:02:10,610
减少嵌套。所以我们要在

39
00:02:10,610 --> 00:02:16,790
React 里面重新把 mixins 添加回来吗？ [对 ... 不...]

40
00:02:16,790 --> 00:02:20,310
对了，不，不，我们不会添加 mixins。

41
00:02:20,310 --> 00:02:23,040
啊，我的意思是之前使用

42
00:02:23,040 --> 00:02:25,230
mixins 的代码并不是无法使用了。

43
00:02:25,230 --> 00:02:27,600
但是我们不再推荐在 React 里使用 mixins。

44
00:02:27,600 --> 00:02:29,880
如果你好奇我们这么做的原因，可以在 React Blog 里面

45
00:02:29,880 --> 00:02:32,910
查看我们之前写的一篇文章，题目是

46
00:02:32,910 --> 00:02:35,040
《 Mixins 是有害的》。

47
00:02:35,040 --> 00:02:38,910
在文章中，根据我们的

48
00:02:38,910 --> 00:02:42,420
实验结果，我们发现 mixins 带来的问题

49
00:02:42,420 --> 00:02:45,000
远比它解决的问题

50
00:02:45,000 --> 00:02:47,790
多。因此，我们不推荐大家

51
00:02:47,790 --> 00:02:51,870
使用 mixins。那么也许

52
00:02:51,870 --> 00:02:53,310
我们解决不了这个问题了，

53
00:02:53,310 --> 00:02:55,860
因为这是 React 组件模型固有的

54
00:02:55,860 --> 00:02:57,780
问题。也许我们不得不

55
00:02:57,780 --> 00:03:10,470
选择接受现实。[笑声] 或者也许

56
00:03:10,470 --> 00:03:12,510
有另外一种书写组件的

57
00:03:12,510 --> 00:03:15,720
形式，可以避免

58
00:03:15,720 --> 00:03:19,200
这些问题。这也就是今天

59
00:03:19,200 --> 00:03:22,680
我将要分享的内容。但是在

60
00:03:22,680 --> 00:03:24,840
开始分享我们在 React 的

61
00:03:24,840 --> 00:03:27,960
改动和新特性之前，我想先讲讲

62
00:03:27,960 --> 00:03:31,200
一年前我们建立的

63
00:03:31,200 --> 00:03:34,290
RFC 流程，RFC 表示

64
00:03:34,290 --> 00:03:36,840
request for comments，它意味着

65
00:03:36,840 --> 00:03:38,880
无论是我们还是其他人

66
00:03:38,880 --> 00:03:40,680
想要对 React 做出

67
00:03:40,680 --> 00:03:43,620
大量变化或者添加新特性时,

68
00:03:43,620 --> 00:03:46,830
都需要撰写一个提案，提案里面

69
00:03:46,830 --> 00:03:49,260
需要包含动机的详情和

70
00:03:49,260 --> 00:03:51,660
该提案如何工作的详细设计。

71
00:03:51,660 --> 00:03:56,250
这正是我们要做的事情。

72
00:03:56,250 --> 00:03:59,520
我们非常兴奋地宣布：我们已经

73
00:03:59,520 --> 00:04:02,040
准备好了一个提案

74
00:04:02,040 --> 00:04:05,520
来解决这三个问题。

75
00:04:05,520 --> 00:04:09,420
重要的是，本提案没有

76
00:04:09,420 --> 00:04:11,820
不向下兼容的变化，也没有弃用任何功能。

77
00:04:11,820 --> 00:04:15,990
本提案是严格添加性的、可选择的

78
00:04:15,990 --> 00:04:20,790
而且增加了一些新的 APIs 来
 
79
00:04:20,790 --> 00:04:23,610
帮助我们解决这些问题。并且我们

80
00:04:23,610 --> 00:04:25,709
希望听到你们对本提案的反馈，

81
00:04:25,709 --> 00:04:28,620
这也是为什么我们在今天发布本提案

82
00:04:28,620 --> 00:04:31,440
的原因。我们想过很多

83
00:04:31,440 --> 00:04:33,510
发布本提案的方式，

84
00:04:33,510 --> 00:04:35,370
也许我们可以写好提案后，

85
00:04:35,370 --> 00:04:39,240
提出一个 RFC 然后放在那里。但是既然

86
00:04:39,240 --> 00:04:41,700
我们总是要召开 React 大会，我们决定

87
00:04:41,700 --> 00:04:45,650
在本次大会上发布这个提案。那么，

88
00:04:45,650 --> 00:04:49,710
接下来进入 Demo 环节。

89
00:04:49,710 --> 00:04:59,479
[掌声]

90
00:04:59,479 --> 00:05:06,929
我的屏幕已经投在了显示器上。对不起，

91
00:05:06,929 --> 00:05:19,670
有点技术故障。

92
00:05:19,670 --> 00:05:22,280
呃，有谁会用这个投影仪，来

93
00:05:22,280 --> 00:05:33,250
帮帮我。[笑声] 呃，我能复制我的桌面吗？

94
00:05:33,250 --> 00:05:41,290
请。

95
00:05:41,290 --> 00:05:46,970
(我能) 是啊。 [笑声]

96
00:05:46,970 --> 00:05:50,370
好的，但是屏幕上没有显示，我

97
00:05:50,370 --> 00:05:53,980
什么都看不到。 [笑声]

98
00:05:53,980 --> 00:06:08,390
这就是我现在的问题。 [掌声]

99
00:06:08,390 --> 00:06:17,180
好的，灾难过去了。[笑声]

100
00:06:17,180 --> 00:06:22,020
好的，嗯，让我来稍微调整下

101
00:06:22,020 --> 00:06:27,960
文字大小。你们能看清吗？ [可以的。] 好的。

102
00:06:27,960 --> 00:06:34,140
那么，我们来看，这里是一个普通的 React 组件，

103
00:06:34,140 --> 00:06:36,840
这是一个 Row 组件，这里有一些

104
00:06:36,840 --> 00:06:39,870
样式，然后渲染出一个

105
00:06:39,870 --> 00:06:43,170
人名。我们想要做的是

106
00:06:43,170 --> 00:06:47,340
让这个名字可编辑。那么我们平时在 React 里

107
00:06:47,340 --> 00:06:49,560
通常是怎么做的呢？我们需要

108
00:06:49,560 --> 00:06:52,200
在这里添加一个 input，需要将这些内容放到

109
00:06:52,200 --> 00:06:54,630
class 里面返回，添加一些本地

110
00:06:54,630 --> 00:06:56,400
state，让 state 来

111
00:06:56,400 --> 00:06:58,740
驱动 input。这也是我

112
00:06:58,740 --> 00:07:01,190
准备做的事情。这也是现今大家通常做的事情。

113
00:07:01,190 --> 00:07:05,390
我要导出 default class

114
00:07:05,390 --> 00:07:12,720
Greeting 继承 React.Component。我也

115
00:07:12,720 --> 00:07:14,910
只会在这里使用稳定的 JavaScript

116
00:07:14,910 --> 00:07:20,840
语法。接下来是 constructor props, super props。

117
00:07:20,840 --> 00:07:25,670
在这里把 state 里的 name 初始化为

118
00:07:25,670 --> 00:07:30,960
Mary。接下来我要

119
00:07:30,960 --> 00:07:34,320
声明一个 render 函数，复制一下这段代码然后

120
00:07:34,320 --> 00:07:41,950
粘贴到这里。

121
00:07:41,950 --> 00:07:44,680
对不起。

122
00:07:44,680 --> 00:07:48,040
好的。我希望这里不再

123
00:07:48,040 --> 00:07:49,450
仅仅渲染 name，我希望这里可以渲染一个

124
00:07:49,450 --> 00:07:51,400
input。我把这里替换为

125
00:07:51,400 --> 00:07:56,320
一个 input，然后 input 的值设置为

126
00:07:56,320 --> 00:08:00,450
this.state.name。 然后

127
00:08:00,450 --> 00:08:03,160
在 input 输入发生变化时，调用

128
00:08:03,160 --> 00:08:06,910
this.handleNameChange，这是我的

129
00:08:06,910 --> 00:08:10,570
change 回调函数。我把它

130
00:08:10,570 --> 00:08:13,330
声明在这里，当名字发生变化时，

131
00:08:13,330 --> 00:08:16,660
像我们通常做的那样调用 setState 方法。然后

132
00:08:16,660 --> 00:08:19,900
将 name 设置为 e.target.value

133
00:08:19,900 --> 00:08:26,440
对吧。如果我编辑 ... [页面上报了 TypeError 的错误] 好吧，所以我

134
00:08:26,440 --> 00:08:33,070
应该去绑定 ... [笑声] 对不起，我需要在这里绑定

135
00:08:33,070 --> 00:08:36,940
events 事件。 好的，现在这样

136
00:08:36,940 --> 00:08:40,390
我们就可以编辑它了，运行正常。

137
00:08:40,390 --> 00:08:43,450
这个 class 组件我们应该非常熟悉了。你如果

138
00:08:43,450 --> 00:08:45,280
使用 React 开发可能会遇到很多类似的

139
00:08:45,280 --> 00:08:52,060
代码。但让我们后退一步，如果

140
00:08:52,060 --> 00:08:55,300
想要使用 state 时，能否不必须使用

141
00:08:55,300 --> 00:08:58,420
class 组件？我不确定

142
00:08:58,420 --> 00:09:00,800
它如何运行。但是我就准备

143
00:09:00,800 --> 00:09:02,560
跟据我的已知来进行，我需要渲染一个

144
00:09:02,560 --> 00:09:06,390
input。所以我在这里放入一个 input。

145
00:09:06,390 --> 00:09:08,979
这个 input 的 value 的值为

146
00:09:08,979 --> 00:09:11,469
当前的 name 的值，所以我就传入

147
00:09:11,469 --> 00:09:14,710
name 值。我不知道从哪里获取 name。

148
00:09:14,710 --> 00:09:18,359
它不是从 props 里面来，嗯，

149
00:09:18,359 --> 00:09:22,410
我就在这里声明，我不知道它的值，

150
00:09:22,410 --> 00:09:26,200
之后我再填写这一块。呃，这里应该也有一个

151
00:09:26,200 --> 00:09:27,790
change 回调函数，我在

152
00:09:27,790 --> 00:09:33,089
这里声明 onChange 函数 handleNameChange。

153
00:09:33,089 --> 00:09:38,229
我在这里添加一个函数来

154
00:09:38,229 --> 00:09:42,160
处理事件。在这里我想要通知 React

155
00:09:42,160 --> 00:09:45,430
设置 name 值到某处，但又一次地，

156
00:09:45,430 --> 00:09:47,200
我不确定在 functional 组件里如何实现

157
00:09:47,200 --> 00:09:48,999
这个功能。因此我就直接调用

158
00:09:48,999 --> 00:09:51,280
一个叫做 setName 的方法。

159
00:09:51,280 --> 00:09:57,010
使用当前的 input 的值。我把它

160
00:09:57,010 --> 00:10:06,570
声明在这里。

161
00:10:06,570 --> 00:10:09,040
好吧，由于这两件事情

162
00:10:09,040 --> 00:10:11,080
是密切相关的，对吧。其中一个是 state 里

163
00:10:11,080 --> 00:10:13,630
name 变量的当前值，

164
00:10:13,630 --> 00:10:17,440
而另一个是一个函数，

165
00:10:17,440 --> 00:10:20,700
该函数让我们去设置 state 里的 name 变量。

166
00:10:20,700 --> 00:10:22,930
由于这两件事情

167
00:10:22,930 --> 00:10:24,820
非常相关，我将它们

168
00:10:24,820 --> 00:10:29,950
合并到一起作为一对值。

169
00:10:29,950 --> 00:10:31,390
我们从某处一同获取到

170
00:10:31,390 --> 00:10:35,220
它们的值。所以问题是我从哪里获取到它们？

171
00:10:35,220 --> 00:10:40,050
答案是从 React 本地状态里面获取。 那么我如何

172
00:10:40,050 --> 00:10:42,370
在 function 组件里面获取到 React 到本地状态呢？

173
00:10:42,370 --> 00:10:46,960
嗯，我直接使用 useState

174
00:10:46,960 --> 00:10:53,940
会怎样。

175
00:10:53,940 --> 00:11:01,230
把初始到状态传给 useState 函数来指定它的初始值。

176
00:11:01,230 --> 00:11:08,010
我们来看一下程序运行是否正常。是的，运行正常。

177
00:11:08,010 --> 00:11:17,310
[掌声和欢呼声]

178
00:11:17,310 --> 00:11:19,630
那么我们来比较一下这两种

179
00:11:19,630 --> 00:11:25,120
方式。在左侧是我们熟悉的

180
00:11:25,120 --> 00:11:27,700
class 组件。这里 state 必须

181
00:11:27,700 --> 00:11:31,180
是一个对象。嗯，我们绑定一些事件

182
00:11:31,180 --> 00:11:33,160
处理函数以便调用。在

183
00:11:33,160 --> 00:11:36,099
事件处理函数里面使用了 this.setState 方法。

184
00:11:36,099 --> 00:11:39,160
当我们调用 setState 方法时，

185
00:11:39,160 --> 00:11:41,020
实际上并没有直接将值设置到 state 里面，

186
00:11:41,020 --> 00:11:44,620
state 作为参数合并到

187
00:11:44,620 --> 00:11:47,050
state 对象里。而当我想要获取

188
00:11:47,050 --> 00:11:49,120
state 时，我们需要调用

189
00:11:49,120 --> 00:11:52,359
this.state.something。那么我们再来

190
00:11:52,359 --> 00:11:55,359
看右侧的例子：我们不需要使用

191
00:11:55,359 --> 00:11:57,940
this.state.something 来获取 state。

192
00:11:57,940 --> 00:12:00,339
因为 state 里的 name 变量

193
00:12:00,339 --> 00:12:02,530
在函数里已经可用。它就是

194
00:12:02,530 --> 00:12:05,440
一个变量。同样的，当我们

195
00:12:05,440 --> 00:12:07,540
需要设置 state 时，我们不需要

196
00:12:07,540 --> 00:12:11,320
使用 this.something。因为

197
00:12:11,320 --> 00:12:13,450
函数也可以让我们在其作用域内

198
00:12:13,450 --> 00:12:19,270
设置 name 的值。那么

199
00:12:19,270 --> 00:12:25,560
useState 到底是什么呢？ UseState 是一个 hook。

200
00:12:25,560 --> 00:12:29,200
Hook 是一个 React 提供的函数，

201
00:12:29,200 --> 00:12:32,670
它可以让你在 function 组件中“钩” 到

202
00:12:32,670 --> 00:12:34,999
一些 React 特性。

203
00:12:34,999 --> 00:12:38,979
而 useState 是我们今天讲到的第一个

204
00:12:38,979 --> 00:12:40,870
hook，后面还有

205
00:12:40,870 --> 00:12:43,089
一些更多的 hook。我们会在后面

206
00:12:43,089 --> 00:12:52,250
看到它们。

207
00:12:52,250 --> 00:12:54,630
好的，让我们回到我们

208
00:12:54,630 --> 00:12:58,170
熟悉的 class 例子。我们接下来想要

209
00:12:58,170 --> 00:13:01,050
添加第二个区域。比如，

210
00:13:01,050 --> 00:13:04,319
添加一个姓氏的区域。那么我们通常的做法是

211
00:13:04,319 --> 00:13:07,109
在 state 添加一个新 key。

212
00:13:07,109 --> 00:13:13,020
我把这行复制然后粘贴到这里。

213
00:13:13,020 --> 00:13:18,569
这里改成 surname。在

214
00:13:18,569 --> 00:13:21,630
这里渲染，这里是 surname 和 handleSurnameChange。

215
00:13:21,630 --> 00:13:24,989
我再来复制

216
00:13:24,989 --> 00:13:30,260
这个事件处理函数，把这里改成 surname。

217
00:13:30,260 --> 00:13:42,810
别忘了绑定这个函数。

218
00:13:42,810 --> 00:13:49,830
好的，Mary Poppins 显示出来了，我们可以看到

219
00:13:49,830 --> 00:13:54,180
程序运行正常。那么我们如何使用 hook 来实现相同的

220
00:13:54,180 --> 00:13:59,999
功能呢？我们需要做的一件事情是把我们的 state

221
00:13:59,999 --> 00:14:02,489
改为一个对象。可以看到，

222
00:14:02,489 --> 00:14:05,310
使用 hook 的 state 并不强制其类型

223
00:14:05,310 --> 00:14:06,989
必须为对象。它可以是任何原生

224
00:14:06,989 --> 00:14:09,090
类型。我们可以在需要的时候把它

225
00:14:09,090 --> 00:14:11,460
变为对象，但是我们不用必须这么做。

226
00:14:11,460 --> 00:14:15,300
从概念上讲，surname 和

227
00:14:15,300 --> 00:14:19,320
name 关系不大。所以

228
00:14:19,320 --> 00:14:21,150
我们需要做的是，再次调用 useState hook 来

229
00:14:21,150 --> 00:14:24,780
声明第二个 state

230
00:14:24,780 --> 00:14:26,719
变量。

231
00:14:26,719 --> 00:14:29,940
在这里我声明 surname，当然我可以给它起

232
00:14:29,940 --> 00:14:31,589
任何名字，因为它就是我程序里的一个变量。

233
00:14:31,589 --> 00:14:37,050
再来设置 setSurname。调用 useState，

234
00:14:37,050 --> 00:14:39,599
传入 state 初始

235
00:14:39,599 --> 00:14:41,510
变量 'Poppins'。

236
00:14:41,510 --> 00:14:43,800
我再一次复制和粘贴

237
00:14:43,800 --> 00:14:51,060
这个 Row 片段。改为 surname，值改为 surname，

238
00:14:51,060 --> 00:14:55,680
onchange 事件改为 handleSurnameChange。当用户编辑

239
00:14:55,680 --> 00:15:03,089
surname 时，不是 sir name，我们

240
00:15:03,089 --> 00:15:07,920
希望能够修改 surname 的值。

241
00:15:07,920 --> 00:15:14,300
我们来看看能否正常运行。

242
00:15:14,300 --> 00:15:22,660
耶，运行正常。 [掌声]

243
00:15:22,660 --> 00:15:26,630
所以我们可以看到，我们可以在组件里

244
00:15:26,630 --> 00:15:29,960
使用多次 hook。 我们来更详细地比较

245
00:15:29,960 --> 00:15:34,400
这两种方式。在

246
00:15:34,400 --> 00:15:37,040
左侧我们熟悉的 class 组件里的 state

247
00:15:37,040 --> 00:15:40,010
总是对象，具有多个字段，

248
00:15:40,010 --> 00:15:42,620
需要调用 setState 函数将其中的

249
00:15:42,620 --> 00:15:45,770
某些值合并进 state 对象中。当我们需要

250
00:15:45,770 --> 00:15:47,510
获取它时，需要调用

251
00:15:47,510 --> 00:15:52,400
this.state.something。在右侧使用 hook 的

252
00:15:52,400 --> 00:15:55,760
例子中，我们使用了

253
00:15:55,760 --> 00:15:59,990
两次 hook。而且声明了两个

254
00:15:59,990 --> 00:16:03,830
变量：name 和 surname。而且每当

255
00:16:03,830 --> 00:16:06,560
我们调用 setName 或 setSurname，

256
00:16:06,560 --> 00:16:08,750
这时 React 会接到需要

257
00:16:08,750 --> 00:16:11,000
重新渲染该组件的通知，就和

258
00:16:11,000 --> 00:16:13,850
调用 setState 一样。所以下一次

259
00:16:13,850 --> 00:16:16,370
React 渲染组件会

260
00:16:16,370 --> 00:16:19,580
将当前的 name 和

261
00:16:19,580 --> 00:16:23,510
surname 传递给组件。而且我们可以

262
00:16:23,510 --> 00:16:25,520
直接使用这些 state 变量，不需要调用

263
00:16:25,520 --> 00:16:36,400
this.state.something。

264
00:16:36,400 --> 00:16:39,640
好的。我们再回到我们的 class 组件的

265
00:16:39,640 --> 00:16:43,510
例子。有没我们知道的其他的

266
00:16:43,510 --> 00:16:46,479
React 特性呢？那么另外一个你可能

267
00:16:46,479 --> 00:16:48,670
希望在组件里面做的事情就是

268
00:16:48,670 --> 00:16:52,570
读取 context。有可能你对 context

269
00:16:52,570 --> 00:16:54,849
还不熟悉，它就像一种

270
00:16:54,849 --> 00:16:57,489
为了子树准备的全局变量。它

271
00:16:57,489 --> 00:17:00,130
在读取当前

272
00:17:00,130 --> 00:17:02,859
主题或者是当前

273
00:17:02,859 --> 00:17:05,650
用户正在使用的语言很有用。它可以

274
00:17:05,650 --> 00:17:08,050
有效避免总是

275
00:17:08,050 --> 00:17:10,150
通过 props 传值，当所有组件需要

276
00:17:10,150 --> 00:17:13,030
都需要读取一些相同变量的时候。所以我们

277
00:17:13,030 --> 00:17:17,410
将要导入 ThemeContext 和

278
00:17:17,410 --> 00:17:19,989
LocaleContext，这两个 context 我已经在

279
00:17:19,989 --> 00:17:23,320
另一个文件里定义好了。可能你们

280
00:17:23,320 --> 00:17:25,900
最熟悉的用来消费 context，

281
00:17:25,900 --> 00:17:27,219
尤其是消费多个

282
00:17:27,219 --> 00:17:30,040
context 的 API 就是 render prop API。

283
00:17:30,040 --> 00:17:33,219
就像这样写。我往下滚动

284
00:17:33,219 --> 00:17:36,729
到这里。我们使用 ThemeContext

285
00:17:36,729 --> 00:17:40,589
Consumer 获得主题。

286
00:17:40,589 --> 00:17:43,420
在我的例子里，主题就是个简单的

287
00:17:43,420 --> 00:17:50,109
样式。我把这段代码复制，将其全部放入

288
00:17:50,109 --> 00:17:55,450
render prop 内部。将

289
00:17:55,450 --> 00:18:01,150
className 赋值为 'theme'。好的，

290
00:18:01,150 --> 00:18:04,280
非常老旧的样式。[笑声]

291
00:18:04,280 --> 00:18:06,770
我也想展示当前的

292
00:18:06,770 --> 00:18:09,739
语言，因此我将要使用

293
00:18:09,739 --> 00:18:18,290
LocaleContext Consumer。我们再来渲染

294
00:18:18,290 --> 00:18:22,670
另一行，把这行代码复制

295
00:18:22,670 --> 00:18:27,969
粘贴到这里，改成 language。

296
00:18:27,969 --> 00:18:34,760
Language。在这里渲染。好的，我们能够看到

297
00:18:34,760 --> 00:18:37,550
context 运行了。这也许是

298
00:18:37,550 --> 00:18:39,920
最普通的消费 context 情况了。实际上，我们

299
00:18:39,920 --> 00:18:41,780
在 React 16.6 版本上增加了一个更加方便的 API

300
00:18:41,780 --> 00:18:45,800
来获取它。呃，但是

301
00:18:45,800 --> 00:18:47,900
这就是你们常见的多

302
00:18:47,900 --> 00:18:53,479
context 的情形。那么我们看一下

303
00:18:53,479 --> 00:18:57,469
如何使用 hook 实现相同的功能。就像我们所

304
00:18:57,469 --> 00:18:59,780
说，state 是 React

305
00:18:59,780 --> 00:19:02,690
的基础特性，因此我们可以使用 useState 来获取 state。

306
00:19:02,690 --> 00:19:07,339
那么如果我们想要使用 context，我需要导入

307
00:19:07,339 --> 00:19:10,760
我的 contexts。这里导入

308
00:19:10,760 --> 00:19:17,500
ThemeContext 和 LocaleContext。

309
00:19:17,500 --> 00:19:20,660
现在如果我想在我组件里使用

310
00:19:20,660 --> 00:19:27,200
context，我可以使用 useContext。然后为了

311
00:19:27,200 --> 00:19:31,239
获取当前的主题，我可以使用 context

312
00:19:31,239 --> 00:19:35,060
ThemeContext。为了获取当前的

313
00:19:35,060 --> 00:19:39,410
语言，我可以使用 context LocaleContext。

314
00:19:39,410 --> 00:19:42,560
这里 useContext 不只是读取了 context，

315
00:19:42,560 --> 00:19:44,719
它也订阅了该组件，当 context 发生变化，

316
00:19:44,719 --> 00:19:47,690
组件随之更新。但现在 useContext 就

317
00:19:47,690 --> 00:19:49,880
给出了 ThemeContext 的当前值 theme，所以我可以

318
00:19:49,880 --> 00:19:56,150
将其赋给 className。然后我来添加一个

319
00:19:56,150 --> 00:20:05,270
兄弟节点，label 改为 Language， 把 locale 放到

320
00:20:05,270 --> 00:20:09,240
这里。

321
00:20:09,240 --> 00:20:18,410
[掌声]

322
00:20:18,410 --> 00:20:21,150
那么，让我们，让我们比较这两个

323
00:20:21,150 --> 00:20:25,170
方法。这是传统的

324
00:20:25,170 --> 00:20:28,370
render prop API 的使用方式。

325
00:20:28,370 --> 00:20:31,140
非常清楚地显示了它正在做什么。

326
00:20:31,140 --> 00:20:34,650
但是它还包含了一点点的

327
00:20:34,650 --> 00:20:38,430
嵌套，而且你遇到这个问题不只是

328
00:20:38,430 --> 00:20:39,930
使用 context 的情况，你会在任何一种

329
00:20:39,930 --> 00:20:44,880
render prop API 的使用中遇到这个问题。我们使用 hook

330
00:20:44,880 --> 00:20:49,500
也能做同样的事情。但是代码会更扁平。那么我们

331
00:20:49,500 --> 00:20:51,359
来看一下，我们使用了两个 useContext，

332
00:20:51,359 --> 00:20:53,820
从中我们得到了 theme 和 locale。

333
00:20:53,820 --> 00:21:00,120
然后我们可以使用它们了。那么，你可能

334
00:21:00,120 --> 00:21:01,979
想问 React 是如何

335
00:21:01,979 --> 00:21:04,739
知道的。例如，我在这调用了两个

336
00:21:04,739 --> 00:21:07,140
useState。所以它是如何知道

337
00:21:07,140 --> 00:21:09,390
哪一个 state 和调用的哪一个

338
00:21:09,390 --> 00:21:13,770
useState 是相对应的。答案是

339
00:21:13,770 --> 00:21:16,859
React 依赖于这些

340
00:21:16,859 --> 00:21:20,430
调用的顺序。这可能有一点不太寻常。

341
00:21:20,430 --> 00:21:24,630
为了让它正确地运行起来。

342
00:21:24,630 --> 00:21:26,940
当你在使用 hook 的时候，这儿有一条你需要去遵循的规则。

343
00:21:26,940 --> 00:21:30,450
这条规则就是

344
00:21:30,450 --> 00:21:34,170
你不能在条件判断里面调用 hook。

345
00:21:34,170 --> 00:21:36,690
它必须在你的组件的顶层。

346
00:21:36,690 --> 00:21:39,150
如果我做一些类似于 if

347
00:21:39,150 --> 00:21:43,380
props 条件的判断，然后我在这里面调用 useState

348
00:21:43,380 --> 00:21:45,989
hook。实际上，我们有一个

349
00:21:45,989 --> 00:21:49,020
linter 插件用来提示

350
00:21:49,020 --> 00:21:51,000
'This is not the correct way to use

351
00:21:51,000 --> 00:21:55,050
hooks'。我们意识到这是一个 

352
00:21:55,050 --> 00:21:59,640
不同寻常的限制，嗯，但是这对 hook 正常

353
00:21:59,640 --> 00:22:02,190
运行十分重要，也

354
00:22:02,190 --> 00:22:04,920
可以使事情变得更明确，我

355
00:22:04,920 --> 00:22:07,380
认为你们会喜欢它的，我等会儿会向你们

356
00:22:07,380 --> 00:22:11,359
展示它。

357
00:22:11,359 --> 00:22:17,970
那么，让我们回头看看我们的 class。

358
00:22:17,970 --> 00:22:20,040
你使用 class 想要

359
00:22:20,040 --> 00:22:23,880
达到的另一件事可能就是生命周期

360
00:22:23,880 --> 00:22:26,880
方法。所以最普通的使用

361
00:22:26,880 --> 00:22:28,620
生命周期方法的案例就是你想要

362
00:22:28,620 --> 00:22:31,710
执行一些副作用，例如发送

363
00:22:31,710 --> 00:22:34,170
请求，执行某些

364
00:22:34,170 --> 00:22:37,380
调用浏览器 API 监测的必要的 DOM 变化。

365
00:22:37,380 --> 00:22:39,570
所以，你可能想要

366
00:22:39,570 --> 00:22:41,490
做一些类似于这个，但是你不能使用在

367
00:22:41,490 --> 00:22:43,950
渲染阶段做这件事情。因为它还没有

368
00:22:43,950 --> 00:22:46,579
渲染完成。因此，你在 React 中使用

369
00:22:46,579 --> 00:22:49,770
副作用的方法是声明一个

370
00:22:49,770 --> 00:22:52,200
类似于 componentDidMount 的生命周期方法。

371
00:22:52,200 --> 00:22:58,140
那么比如说，嗯，让我向你们展示一下

372
00:22:58,140 --> 00:23:00,000
这个。那么，你看到在屏幕的顶部，

373
00:23:00,000 --> 00:23:03,450
它显示的是 React App。这里实际上有一个

374
00:23:03,450 --> 00:23:06,030
让我们更新这个标题的浏览器 API。

375
00:23:06,030 --> 00:23:09,810
比如说我们想要这个页签的标题变成

376
00:23:09,810 --> 00:23:12,660
这个人的名字，并且能够随着我输入的值而改变。

377
00:23:12,660 --> 00:23:15,810
现在我要初始化它。

378
00:23:15,810 --> 00:23:17,670
嗯，这儿有一个浏览器 API 可以做

379
00:23:17,670 --> 00:23:21,089
这件事，那就是 document.title 等于

380
00:23:21,089 --> 00:23:24,720
this.state.name 加空格加

381
00:23:24,720 --> 00:23:29,250
this.state.surname。现在我们可以

382
00:23:29,250 --> 00:23:33,570
看见这里显示出了 Mary Poppins。但是如果我现在，

383
00:23:33,570 --> 00:23:37,110
如果我编辑它，它不会

384
00:23:37,110 --> 00:23:39,090
自动地更新，因为我也

385
00:23:39,090 --> 00:23:41,930
需要实现 componentDitUpdate 方法，

386
00:23:41,930 --> 00:23:44,940
为了让副作用

387
00:23:44,940 --> 00:23:48,480
和我渲染保持一致。所以我

388
00:23:48,480 --> 00:23:50,060
在这里声明 componentDitUpdate,

389
00:23:50,060 --> 00:23:57,150
然后复制这段代码并粘贴到这里。

390
00:23:57,150 --> 00:24:00,440
那么，现在显示的是 Mary Poppins，但是如果我

391
00:24:00,440 --> 00:24:04,560
开始编辑它，这个文档的标题也更新了。

392
00:24:04,560 --> 00:24:06,960
这就是我们如何在一个

393
00:24:06,960 --> 00:24:15,640
class 里执行一个副作用的例子。

394
00:24:15,640 --> 00:24:21,830
那么我们要如何用 hook 实现相同的功能呢？

395
00:24:21,830 --> 00:24:23,960
执行副作用的能力是 

396
00:24:23,960 --> 00:24:27,970
React 组件的另一个核心特性。

397
00:24:27,970 --> 00:24:32,779
所以如果我们想要使用的

398
00:24:32,779 --> 00:24:37,700
effect，我们需要从 React 里导入一个 useEffect。

399
00:24:37,700 --> 00:24:43,760
然后我们要告诉 React

400
00:24:43,760 --> 00:24:46,100
在 React 清除组件之后

401
00:24:46,100 --> 00:24:48,740
对 DOM 做什么。所以我们在 useEffect

402
00:24:48,740 --> 00:24:51,590
里面传递一个函数作为参数，在函数里执行副作用，

403
00:24:51,590 --> 00:24:54,110
在这里设置 document.title

404
00:24:54,110 --> 00:24:57,610
等于 name 加空格加

405
00:24:57,610 --> 00:25:05,150
surname。可以看到，页面标题显示为 Mary Poppins。

406
00:25:05,150 --> 00:25:10,100
如果我开始编辑它，页面标题实际上也会

407
00:25:10,100 --> 00:25:11,769
更新。

408
00:25:11,769 --> 00:25:15,289
所以，userEffect 默认会在

409
00:25:15,289 --> 00:25:18,799
初始渲染和每一次

410
00:25:18,799 --> 00:25:21,650
更新之后执行。所以通过默认的，页面标题

411
00:25:21,650 --> 00:25:24,980
与这里渲染的内容保持一致。

412
00:25:24,980 --> 00:25:26,960
如果出于考虑性能原因

413
00:25:26,960 --> 00:25:28,850
或者你有特殊的逻辑，可以选择不采用这种行为。

414
00:25:28,850 --> 00:25:32,539
在我之后，Ryan 的演讲

415
00:25:32,539 --> 00:25:37,910
将会谈到一些关于这个的内容。那么让我们来

416
00:25:37,910 --> 00:25:43,700
比较这两个方法。在这个，这个

417
00:25:43,700 --> 00:25:45,890
class 里，我们将函数分开 ... 我们将

418
00:25:45,890 --> 00:25:48,860
逻辑分开到不同名称的生命周期方法中。所以

419
00:25:48,860 --> 00:25:50,210
这是我们为什么会有 componentDidMount,

420
00:25:50,210 --> 00:25:51,799
componentDitUpdate 的原因，它们在

421
00:25:51,799 --> 00:25:54,560
不同的时间上被触发。我们有时候

422
00:25:54,560 --> 00:25:56,450
在他们之间重复一些逻辑。我们可以把

423
00:25:56,450 --> 00:25:58,519
这些逻辑放进一个函数里，但是我们仍然不得不

424
00:25:58,519 --> 00:26:00,890
在两个地方调用它，而且要记得

425
00:26:00,890 --> 00:26:04,370
保持一致。通过，通过使用

426
00:26:04,370 --> 00:26:07,610
effect hook，副作用默认

427
00:26:07,610 --> 00:26:09,650
具有一致性，而且可以选择

428
00:26:09,650 --> 00:26:13,340
不使用该默认行为。需要注意的是，

429
00:26:13,340 --> 00:26:15,350
在 class 中我们需要访问 this.state，

430
00:26:15,350 --> 00:26:17,360
所以需要一个特殊的 API 来完成

431
00:26:17,360 --> 00:26:20,570
这个。但是在这个 effect 例子中，我们

432
00:26:20,570 --> 00:26:22,070
实际上不需要一个特殊的 API 去

433
00:26:22,070 --> 00:26:24,040
访问这个 state

434
00:26:24,040 --> 00:26:26,470
变量。因为它已经在

435
00:26:26,470 --> 00:26:28,450
这个函数的作用域里。它在上面已经声明

436
00:26:28,450 --> 00:26:31,270
了。这就是 effect

437
00:26:31,270 --> 00:26:34,780
被声明在组件内部，而

438
00:26:34,780 --> 00:26:37,390
不是，不是在组件外部的原因。因为

439
00:26:37,390 --> 00:26:39,700
这样我们能够访问 state 变量，

440
00:26:39,700 --> 00:26:42,520
能够去设置他们和任何其他

441
00:26:42,520 --> 00:26:45,130
例如像当前 context 的值，

442
00:26:45,130 --> 00:26:56,380
或者是这些 context。

443
00:26:56,380 --> 00:26:58,120
那么，让我们回头看看熟悉的

444
00:26:58,120 --> 00:27:02,290
class 的例子。嗯，其他你可能需要在 class 里

445
00:27:02,290 --> 00:27:04,180
使用生命周期方法实现的就是

446
00:27:04,180 --> 00:27:07,750
订阅功能。你可能想要

447
00:27:07,750 --> 00:27:09,550
去订阅一些浏览器 API，

448
00:27:09,550 --> 00:27:12,040
它会提供给你一些值，例如

449
00:27:12,040 --> 00:27:15,250
窗口的大小。你需要组件随着

450
00:27:15,250 --> 00:27:17,500
这个 state 值的改变更新。

451
00:27:17,500 --> 00:27:20,440
那么我们在 class 里实现这个功能的方法是，

452
00:27:20,440 --> 00:27:23,800
比如说我们想要，嗯，

453
00:27:23,800 --> 00:27:26,590
我们想要监测窗口的宽度。

454
00:27:26,590 --> 00:27:30,610
我将 width 放进 state 里。使用

455
00:27:30,610 --> 00:27:35,560
window.innerWidth 浏览器 API 来初始化。然后我

456
00:27:35,560 --> 00:27:38,980
想要渲染它。嗯，让我们复制并且粘贴

457
00:27:38,980 --> 00:27:47,800
这段代码。这里改为 width。我将

458
00:27:47,800 --> 00:27:49,750
在这个地方渲染它。这里改为 this.state.width。

459
00:27:49,750 --> 00:27:53,590
这就是窗口的宽度了，

460
00:27:53,590 --> 00:27:57,860
而不是 Mary Poppins 的宽度。 [大笑]

461
00:27:57,860 --> 00:28:02,660
我将添加一个，嗯，我将要添加

462
00:28:02,660 --> 00:28:04,580
一个事件监听，所以我们需要真真切切地

463
00:28:04,580 --> 00:28:08,090
监听这个 width 的改变。所以设置

464
00:28:08,090 --> 00:28:12,670
window.addEventListener。

465
00:28:12,670 --> 00:28:15,560
我，我将监听 resize 事件，

466
00:28:15,560 --> 00:28:20,749
handleResize。然后我需要

467
00:28:20,749 --> 00:28:23,330
声明这个事件。在这里

468
00:28:23,330 --> 00:28:27,350
我们更新这个 width 状态，设置为

469
00:28:27,350 --> 00:28:32,150
window.innerWidth。然后我们需要

470
00:28:32,150 --> 00:28:42,229
去绑定它。然后，嗯，然后我也需要

471
00:28:42,229 --> 00:28:44,269
取消订阅。所以我不想因为保留这些订阅

472
00:28:44,269 --> 00:28:46,580
造成内存泄漏。

473
00:28:46,580 --> 00:28:48,140
我想要取消这个事件的订阅。

474
00:28:48,140 --> 00:28:50,600
我们在一个 class 里处理的方式是

475
00:28:50,600 --> 00:28:52,880
创建另一个

476
00:28:52,880 --> 00:28:56,650
叫做 componentWillUnmount 的生命周期方法。然后

477
00:28:56,650 --> 00:28:59,029
我将这段逻辑代码复制并且粘贴

478
00:28:59,029 --> 00:29:01,779
到这里，将这里改为

479
00:29:01,779 --> 00:29:05,299
removeEventListener。我们设置了一个事件

480
00:29:05,299 --> 00:29:06,920
监听，并且我们移除了这个事件

481
00:29:06,920 --> 00:29:08,870
监听。我们可以

482
00:29:08,870 --> 00:29:11,479
通过拖动窗口来验证。你看到

483
00:29:11,479 --> 00:29:17,029
这个 width 正在变化。运行正常。那么

484
00:29:17,029 --> 00:29:18,920
让我们看看如何可以，我们如何

485
00:29:18,920 --> 00:29:31,130
用 hook 实现这个功能。从概念上来说，监听

486
00:29:31,130 --> 00:29:33,709
窗口宽度

487
00:29:33,709 --> 00:29:37,279
与设置文档标题无关。这就是为什么

488
00:29:37,279 --> 00:29:39,320
我们没有把它放入这个 useEffect 里的原因。

489
00:29:39,320 --> 00:29:41,330
它们在概念上是完全独立的副作用，

490
00:29:41,330 --> 00:29:44,060
就像我们可以使用多次的 useState 用来

491
00:29:44,060 --> 00:29:46,610
声明多个 state 

492
00:29:46,610 --> 00:29:49,580
变量，我们可以使用多次 useEffect

493
00:29:49,580 --> 00:29:54,130
来实现不同的副作用。

494
00:29:54,130 --> 00:29:57,560
这里我想要订阅 window.addEventListener 

495
00:29:57,560 --> 00:30:05,259
，resize，handleResize。然后

496
00:30:05,259 --> 00:30:08,719
我需要保存

497
00:30:08,719 --> 00:30:10,130
当前 width 的状态。

498
00:30:10,130 --> 00:30:12,140
所以，我将声明另一组

499
00:30:12,140 --> 00:30:17,330
state 变量。所以这里声明 width 和

500
00:30:17,330 --> 00:30:23,390
setWidth。我们通过 useState

501
00:30:23,390 --> 00:30:27,670
设置他们的初始值为 window.innerWidth。

502
00:30:27,670 --> 00:30:32,450
现在我把 handleResize 函数

503
00:30:32,450 --> 00:30:34,130
声明在这里。因为它

504
00:30:34,130 --> 00:30:37,489
没有在其他地方被调用。然后用

505
00:30:37,489 --> 00:30:44,180
setWidth 来设置当前的 width。嗯，我

506
00:30:44,180 --> 00:30:46,460
需要去渲染它。所以我复制

507
00:30:46,460 --> 00:30:54,580
并粘贴这个 Row。这里改为 width。 

508
00:30:54,580 --> 00:30:58,910
最后我需要在这个 

509
00:30:58,910 --> 00:31:02,060
effect 之后去清除它。所以我需要指定如何

510
00:31:02,060 --> 00:31:05,870
清除。从概念上说，清除

511
00:31:05,870 --> 00:31:08,779
也是这个 effect 的一部分。所以这个 effect

512
00:31:08,779 --> 00:31:12,940
有一个清除的地方。这个顺序，你，

513
00:31:12,940 --> 00:31:16,070
你可以指定如何清除订阅的方法是，

514
00:31:16,070 --> 00:31:21,549
effect 可以选择返回一个函数。

515
00:31:21,549 --> 00:31:25,970
如果它返回一个函数，那么

516
00:31:25,970 --> 00:31:28,039
React 将在 effect 之后

517
00:31:28,039 --> 00:31:30,830
调用这个函数进行清除操作。所以这就是我们

518
00:31:30,830 --> 00:31:37,920
取消订阅的地方。

519
00:31:37,920 --> 00:31:39,870
好的，让我们验证一下

520
00:31:39,870 --> 00:31:49,000
它能否正常运行吧。耶！[掌声]

521
00:31:56,220 --> 00:32:02,640
那么让我们比较这两个方法。在左边，我们使用了一个

522
00:32:02,640 --> 00:32:06,690
熟悉的 class 组件，嗯，在这没有

523
00:32:06,690 --> 00:32:09,539
令人惊喜的东西。我们，我们有一些

524
00:32:09,539 --> 00:32:12,720
副作用，一些相关的逻辑是分开

525
00:32:12,720 --> 00:32:15,360
的：我们可以看到文档的标题

526
00:32:15,360 --> 00:32:17,190
在这里被设置，但是它在这也

527
00:32:17,190 --> 00:32:19,680
被设置了。并且我们在这订阅一个

528
00:32:19,680 --> 00:32:20,610
effect，

529
00:32:20,610 --> 00:32:23,220
抱歉，在这订阅这个事件，但是我们

530
00:32:23,220 --> 00:32:25,650
在这里取消订阅。所以这些事情需要

531
00:32:25,650 --> 00:32:28,710
相互保持同步。而且这个

532
00:32:28,710 --> 00:32:31,260
方法包含了两个不相关的方法，

533
00:32:31,260 --> 00:32:34,950
在这不相关的两行。因此，我，在，在

534
00:32:34,950 --> 00:32:36,690
未来有点难以单独测试它们。

535
00:32:36,690 --> 00:32:41,039
但是它看起来非常熟悉。

536
00:32:41,039 --> 00:32:46,350
所以，这，这也不错。那么这段

537
00:32:46,350 --> 00:32:48,660
代码看起来可能会就不那么熟悉了。但

538
00:32:48,660 --> 00:32:50,039
让我们来看一看这里发生了什么。

539
00:32:50,039 --> 00:32:54,150
嗯，在 hook 中，我们分离代码

540
00:32:54,150 --> 00:32:56,310
不是基于生命周期函数的名字，

541
00:32:56,310 --> 00:32:59,700
而是基于这段代码要做什么。所以

542
00:32:59,700 --> 00:33:01,680
我们可以看到这个有一个 effect，

543
00:33:01,680 --> 00:33:04,289
我们用来更新文档的标题

544
00:33:04,289 --> 00:33:06,090
这是一件这个组件能做的事。

545
00:33:06,090 --> 00:33:09,360
这里有另一个 effect，

546
00:33:09,360 --> 00:33:12,299
它订阅了 window 的 resize 事件，

547
00:33:12,299 --> 00:33:14,610
并且当 window 的大小发生改变时，state 随之更新。

548
00:33:14,610 --> 00:33:18,870
然后，嗯，这个 effect 有一个清除

549
00:33:18,870 --> 00:33:21,000
阶段，它的作用是

550
00:33:21,000 --> 00:33:23,549
移除这个 effect 时，React 取消事件监听

551
00:33:23,549 --> 00:33:26,730
从而避免内存泄漏。如果你

552
00:33:26,730 --> 00:33:28,920
一直仔细观察，你可能注意到

553
00:33:28,920 --> 00:33:31,110
由于 effect 在每次渲染之后运行，

554
00:33:31,110 --> 00:33:33,600
我们会重新订阅。

555
00:33:33,600 --> 00:33:36,150
有一个方法可以优化这个问题。嗯。

556
00:33:36,150 --> 00:33:38,820
默认是一致的，嗯，这

557
00:33:38,820 --> 00:33:40,590
很重要。如果你，例如在这使用一些

558
00:33:40,590 --> 00:33:44,039
prop，我需要去重新订阅一个不同的 id 

559
00:33:44,039 --> 00:33:46,350
，该 id 来自 props 或类似的地方。但是这儿有

560
00:33:46,350 --> 00:33:48,360
一个方法去优化它，并且可以选择不用这个

561
00:33:48,360 --> 00:33:50,250
行为。Ryan 在下一个

562
00:33:50,250 --> 00:34:02,730
演讲中将会提到如何去实现它。

563
00:34:02,730 --> 00:34:07,020
好的，我在这里还想要演示

564
00:34:07,020 --> 00:34:10,830
另外一件事。现在组件已经

565
00:34:10,830 --> 00:34:14,610
非常庞大了，这也没有太大的问题。我们考虑到

566
00:34:14,610 --> 00:34:16,770
在 function 组件中你们有可能

567
00:34:16,770 --> 00:34:19,380
做更多的事情，组件会变得更大，

568
00:34:19,380 --> 00:34:23,850
但也完全没有问题。嗯，但是你有可能

569
00:34:23,850 --> 00:34:25,950
想要复用其他组件里面到一些逻辑，

570
00:34:25,950 --> 00:34:28,620
或者是想要将公用的逻辑抽取出来，或者是想要

571
00:34:28,620 --> 00:34:32,040
分别测试。有趣的是，

572
00:34:32,040 --> 00:34:35,640
hook 调用实际上就是

573
00:34:35,640 --> 00:34:40,650
函数调用。而且组件就是

574
00:34:40,650 --> 00:34:43,920
函数。那么你们是如何在

575
00:34:43,920 --> 00:34:47,550
两个函数之间共享逻辑呢。你们会将公用逻辑提取到

576
00:34:47,550 --> 00:34:50,490
另外一个函数里面。这也是我将要做的

577
00:34:50,490 --> 00:34:53,220
事情。我把这段代码复制

578
00:34:53,220 --> 00:34:58,050
粘贴到这里。我要新建一个

579
00:34:58,050 --> 00:35:04,890
叫做 useWindowWidth 的函数。然后把它

580
00:35:04,890 --> 00:35:08,220
粘贴到这里。我们需要

581
00:35:08,220 --> 00:35:10,350
组件里面的宽度，以便能够将其

582
00:35:10,350 --> 00:35:14,550
渲染。因为我需要在这个函数里面

583
00:35:14,550 --> 00:35:18,890
返回当前宽度。

584
00:35:18,890 --> 00:35:25,410
然后我们回到上面的代码，这样修改：

585
00:35:25,410 --> 00:35:35,640
const width = useWindowWidth。

586
00:35:35,640 --> 00:35:37,370
[掌声]

587
00:35:37,370 --> 00:35:44,080
[欢呼声]

588
00:35:44,080 --> 00:35:51,020
那么这个函数是什么呢？我们并没有做

589
00:35:51,020 --> 00:35:53,060
什么特别的事情，我们仅仅是将逻辑提取到了

590
00:35:53,060 --> 00:35:56,299
一个函数里面。呃，但是这里有一个约定。

591
00:35:56,299 --> 00:35:59,960
我们把这种函数叫做 custom

592
00:35:59,960 --> 00:36:04,610
hook。按照约定，custom hook 的名字

593
00:36:04,610 --> 00:36:08,270
需要以 use 开头。这么约定主要有

594
00:36:08,270 --> 00:36:10,220
两个原因。我们

595
00:36:10,220 --> 00:36:12,890
会读你的函数名或

596
00:36:12,890 --> 00:36:15,590
修改函数名称。但是这是一个

597
00:36:15,590 --> 00:36:17,540
重要的约定，因为首先

598
00:36:17,540 --> 00:36:20,299
以 use 开头来命名 custom hook，可以让我们自动检测是否

599
00:36:20,299 --> 00:36:22,910
违反了我之前说过的第一条规则：

600
00:36:22,910 --> 00:36:25,340
不能在条件判断里面使用 hook。

601
00:36:25,340 --> 00:36:27,830
因此如果我们无法得知哪些函数是

602
00:36:27,830 --> 00:36:29,390
hook，那么我们就无法做到自动检测。

603
00:36:29,390 --> 00:36:33,200
另一个原因是，如果你查看

604
00:36:33,200 --> 00:36:35,720
组件的代码，你可能会想要

605
00:36:35,720 --> 00:36:37,220
知道某个函数里面是否含有

606
00:36:37,220 --> 00:36:39,470
state。因此

607
00:36:39,470 --> 00:36:41,750
这样的约定很重要，

608
00:36:41,750 --> 00:36:44,210
，好的，以 use 开头的函数表示这个函数是

609
00:36:44,210 --> 00:36:47,870
有状态的。在这里 width 变量给了

610
00:36:47,870 --> 00:36:50,690
我们当前的宽度并且订阅了

611
00:36:50,690 --> 00:37:00,020
其更新。如果我们想，我们

612
00:37:00,020 --> 00:37:02,240
可以更进一步。在这个例子里面

613
00:37:02,240 --> 00:37:04,460
也许并不必要，但是

614
00:37:04,460 --> 00:37:06,680
我想要给你一个思路。

615
00:37:06,680 --> 00:37:10,190
嗯，我们也许

616
00:37:10,190 --> 00:37:11,930
设置文档的标题的功能会更加

617
00:37:11,930 --> 00:37:13,820
复杂，你希望能够把它的逻辑提取

618
00:37:13,820 --> 00:37:17,090
出来并单独测试。那么我把这段代码

619
00:37:17,090 --> 00:37:20,390
复制过来粘贴到这里。我可以

620
00:37:20,390 --> 00:37:22,580
写一个新的 custom hook。我把这个 hook 

621
00:37:22,580 --> 00:37:29,450
命名为 useDocumentTitle。由于

622
00:37:29,450 --> 00:37:31,760
name 和 surname 在上下文作用域里

623
00:37:31,760 --> 00:37:34,250
没有意义。我希望调用

624
00:37:34,250 --> 00:37:36,440
标题，标题就是一个

625
00:37:36,440 --> 00:37:38,600
参数，由于 custom hook 就是

626
00:37:38,600 --> 00:37:40,640
javascript 函数，因此他们可以传递

627
00:37:40,640 --> 00:37:43,430
参数，返回值或者

628
00:37:43,430 --> 00:37:46,700
不返回。这里我把 title 设置为

629
00:37:46,700 --> 00:37:49,430
参数。然后在组件里面，

630
00:37:49,430 --> 00:37:54,140
使用 useDocumentTitle，参数为 name 加上

631
00:37:54,140 --> 00:37:55,810
surname。

632
00:37:55,810 --> 00:37:59,420
事实上，我可以更进一步。在这个例子

633
00:37:59,420 --> 00:38:01,700
中是完全没有必要的，但是

634
00:38:01,700 --> 00:38:04,340
同样的道理，也许我们的输入框会更加的

635
00:38:04,340 --> 00:38:06,259
复杂，也许我们需要追踪

636
00:38:06,259 --> 00:38:08,150
输入框的聚焦或

637
00:38:08,150 --> 00:38:09,730
失焦事件，或者输入框是否被校验过、

638
00:38:09,730 --> 00:38:12,680
提交过等等。也许我们还有

639
00:38:12,680 --> 00:38:14,600
更多的逻辑想要从组件中

640
00:38:14,600 --> 00:38:17,000
抽离。嗯，而且想要减少

641
00:38:17,000 --> 00:38:18,950
重复代码。这里已经有了重复

642
00:38:18,950 --> 00:38:21,049
的代码，这两段事件处理函数

643
00:38:21,049 --> 00:38:24,860
几乎一样。那么我们如果

644
00:38:24,860 --> 00:38:26,600
，呃，我把他们删除一段，

645
00:38:26,600 --> 00:38:30,140
然后提取另一段。我要创建另一个

646
00:38:30,140 --> 00:38:31,970
新 hook，把它命名为

647
00:38:31,970 --> 00:38:37,850
useFormInput。这个 hook 是我的

648
00:38:37,850 --> 00:38:40,820
change 处理函数。现在我把这个声明复制

649
00:38:40,820 --> 00:38:45,890
粘贴到这里。这里定义了

650
00:38:45,890 --> 00:38:49,370
输入框的状态。这里不再是

651
00:38:49,370 --> 00:38:51,890
name 和 setName。我把这里改为更通用的

652
00:38:51,890 --> 00:38:56,000
value 和 setValue。我把初始

653
00:38:56,000 --> 00:38:58,460
值作为

654
00:38:58,460 --> 00:39:02,960
参数。这里改为

655
00:39:02,960 --> 00:39:09,529
handleChange，这里改为 setValue。那么

656
00:39:09,529 --> 00:39:12,200
我们该如何做在我们组件里面

657
00:39:12,200 --> 00:39:14,539
使用输入框呢？我们需要

658
00:39:14,539 --> 00:39:16,759
获取当前的 value 和

659
00:39:16,759 --> 00:39:18,740
change 处理函数。这是我们需要

660
00:39:18,740 --> 00:39:21,890
赋给输入框的。所以我们就在 hook 里面

661
00:39:21,890 --> 00:39:26,230
返回他们。嗯，返回 value 和 onChange

662
00:39:26,230 --> 00:39:33,740
handleChange 函数。我们回到组件里面，

663
00:39:33,740 --> 00:39:39,009
这里改为 name 等于 useFormInput，参数 Mary。

664
00:39:39,009 --> 00:39:41,480
这里 name 变为了一个对象，包括

665
00:39:41,480 --> 00:39:45,200
value 和 onChange 函数。这里 surname 等于

666
00:39:45,200 --> 00:39:52,880
useFormInput，初始化参数 Poppins。这里改为

667
00:39:52,880 --> 00:39:55,100
name.value 和 surname.value

668
00:39:55,100 --> 00:39:57,289
因为这两个值才是

669
00:39:57,289 --> 00:40:00,710
我们需要的字符串。接下来我把这里

670
00:40:00,710 --> 00:40:07,100
删除，然后将其改为 spread 属性。

671
00:40:07,100 --> 00:40:12,060
有人在笑。[笑声] 好的。我们

672
00:40:12,060 --> 00:40:15,960
来验证一下，是的，运行正常。每次

673
00:40:15,960 --> 00:40:18,000
我们调用 hook，其状态都是

674
00:40:18,000 --> 00:40:20,880
完全独立的。这是因为

675
00:40:20,880 --> 00:40:23,040
我们依赖调用 hook 的顺序，而不是

676
00:40:23,040 --> 00:40:25,290
通过名称或其他方式来实现的。所以你可以

677
00:40:25,290 --> 00:40:27,390
多次调用相同的 hook。每次调用都会

678
00:40:27,390 --> 00:40:32,940
获取其自身的本地状态。

679
00:40:32,940 --> 00:40:35,490
我们最后一次来比较

680
00:40:35,490 --> 00:40:45,720
这两种方式。嗯，在左侧我们熟悉的

681
00:40:45,720 --> 00:40:48,000
class 组件例子里，在一个对象里面

682
00:40:48,000 --> 00:40:51,600
有一些 state，绑定了一些

683
00:40:51,600 --> 00:40:54,810
方法，有一些逻辑分散到了

684
00:40:54,810 --> 00:40:57,060
不同的声明周期方法里面，这些逻辑是

685
00:40:57,060 --> 00:41:02,520
一串事件处理函数。嗯，我们用了

686
00:41:02,520 --> 00:41:04,440
来自 context 的内容来

687
00:41:04,440 --> 00:41:11,310
渲染内容。嗯，这种情况我们相当熟悉了。在右侧窗格

688
00:41:11,310 --> 00:41:13,350
里面，和我们常见的

689
00:41:13,350 --> 00:41:17,130
React 组件不同。但是它是

690
00:41:17,130 --> 00:41:19,770
有意义的。即使你并不知道

691
00:41:19,770 --> 00:41:21,270
这些函数是如何实现的。

692
00:41:21,270 --> 00:41:24,380
你可以看到，这个函数就是用来组织输入框的，

693
00:41:24,380 --> 00:41:26,760
这个函数用了 context 来获取主题和

694
00:41:26,760 --> 00:41:29,460
本地语言，这个函数使用了窗口宽度和

695
00:41:29,460 --> 00:41:33,240
文档标题，然后渲染了一连串的

696
00:41:33,240 --> 00:41:36,360
内容。如果我们想了解更多，我们可以滚动窗口

697
00:41:36,360 --> 00:41:38,670
到下面，可以看到，这就是

698
00:41:38,670 --> 00:41:41,460
输入框如何运行的代码，这里是如何设置

699
00:41:41,460 --> 00:41:44,340
文档标题的代码，而这里是如何设置并订阅

700
00:41:44,340 --> 00:41:47,520
窗口宽度的代码。或许

701
00:41:47,520 --> 00:41:49,920
这里可以是一个 npm 包，实际上

702
00:41:49,920 --> 00:41:52,470
你没有必要了解它是如何实现的。我们可以

703
00:41:52,470 --> 00:41:54,510
将它在组件里面调用，或者在组件之间复制粘贴

704
00:41:54,510 --> 00:41:56,910
他们。

705
00:41:56,910 --> 00:42:00,060
Hook 提供了 custom hook，灵活提供了

706
00:42:00,060 --> 00:42:01,620
创建你自己的

707
00:42:01,620 --> 00:42:04,710
抽象函数的功能，custom hook 不会让你

708
00:42:04,710 --> 00:42:08,100
的 React 组建树变得庞大，而且可以避免

709
00:42:08,100 --> 00:42:14,720
“包装地狱”。

710
00:42:14,720 --> 00:42:16,610
[掌声]

711
00:42:16,610 --> 00:42:22,010
[掌声]

712
00:42:22,010 --> 00:42:23,749
[掌声]

713
00:42:23,749 --> 00:42:27,630
而且重要的是，这两个例子并不是

714
00:42:27,630 --> 00:42:29,489
独立的两个应用。实际上，这两个例子是在

715
00:42:29,489 --> 00:42:32,640
同一个应用里面。我把这个窗口

716
00:42:32,640 --> 00:42:34,590
打开的目的就是想要展示

717
00:42:34,590 --> 00:42:37,650
class 可以和 hook 并肩工作。

718
00:42:37,650 --> 00:42:40,620
而 hook 代表这我们对 React 未来的

719
00:42:40,620 --> 00:42:44,580
期许，嗯，但是我们并不想

720
00:42:44,580 --> 00:42:47,789
做出不向下兼容的改变。我们还需要

721
00:42:47,789 --> 00:42:53,310
保证 class 可以正常运行。

722
00:42:53,310 --> 00:43:02,189
我们回到幻灯片上来。好的，这张幻灯片

723
00:43:02,189 --> 00:43:06,490
就是你们可以发 tweet 的片子。 [笑声]

724
00:43:06,490 --> 00:43:09,490
今天我们向你们展示了 Hook

725
00:43:09,490 --> 00:43:10,660
提案。

726
00:43:10,660 --> 00:43:13,510
呃，hooks 让我们可以在不使用 class 的情况下

727
00:43:13,510 --> 00:43:16,750
使用 React 的众多特性。而且我们没有

728
00:43:16,750 --> 00:43:19,600
弃用 class，但是我们给你们提供了一个

729
00:43:19,600 --> 00:43:21,790
不去写 class 的新选择。我们打算尽快

730
00:43:21,790 --> 00:43:24,250
完成使用 hook 来替代 class 的全部

731
00:43:24,250 --> 00:43:27,070
用例。

732
00:43:27,070 --> 00:43:29,320
目前还有一部分缺失，但是我们正在

733
00:43:29,320 --> 00:43:32,680
处理这部分内容。而且 hook 能够让大家

734
00:43:32,680 --> 00:43:35,140
复用有状态的逻辑，并将其从组件中提取

735
00:43:35,140 --> 00:43:38,230
出来，分别测试，在不同

736
00:43:38,230 --> 00:43:39,850
组件之间复用，并且可以避免

737
00:43:39,850 --> 00:43:42,850
引入“包装地狱”。重要的是，

738
00:43:42,850 --> 00:43:44,560
hook 不是一个破坏性的改动，

739
00:43:44,560 --> 00:43:48,000
完全向后兼容，是严格

740
00:43:48,000 --> 00:43:52,240
添加性的。你可以从

741
00:43:52,240 --> 00:43:54,700
这个 url 查找到我们关于 hook 的

742
00:43:54,700 --> 00:43:59,520
文档。嗯，我们希望

743
00:43:59,520 --> 00:44:03,340
听到你们的反馈，React

744
00:44:03,340 --> 00:44:05,170
社区希望了解到你们对 hook 的

745
00:44:05,170 --> 00:44:07,780
想法，嗯，无论你们喜欢与否。

746
00:44:07,780 --> 00:44:10,420
而且我们发现如果不让大家实际使用 hook，

747
00:44:10,420 --> 00:44:12,070
就会很难收到反意见。

748
00:44:12,070 --> 00:44:17,100
所以我们将 hook 构建发布到了

749
00:44:17,100 --> 00:44:22,000
React 16.7 alpha 版本上。这个不是一个

750
00:44:22,000 --> 00:44:24,760
主要版本，是一个小版本。但是在这个

751
00:44:24,760 --> 00:44:26,730
alpha 版本，你可以尝试使用 hook。

752
00:44:26,730 --> 00:44:30,700
而且我们在 Facebook 的生产环境已经测试

753
00:44:30,700 --> 00:44:33,610
了一个月，因此我们认为

754
00:44:33,610 --> 00:44:36,910
不会有大的缺陷。但是 hook 的 API

755
00:44:36,910 --> 00:44:40,570
可以根据你们的反馈意见

756
00:44:40,570 --> 00:44:44,320
进行调整。而且我不建议你们

757
00:44:44,320 --> 00:44:46,330
把整个应用使用 hook 来

758
00:44:46,330 --> 00:44:50,560
重写。因为首先，hook 目前还在

759
00:44:50,560 --> 00:44:53,400
提案阶段。第二个原因，我个人认为，

760
00:44:53,400 --> 00:44:56,500
使用 hook 的思维方式

761
00:44:56,500 --> 00:44:58,240
需要一个思想上的

762
00:44:58,240 --> 00:45:01,360
改变，也许刚开始你们尝试把 

763
00:45:01,360 --> 00:45:03,310
class 组件转为 hook 写法会比较

764
00:45:03,310 --> 00:45:07,030
困惑。但是我推荐大家

765
00:45:07,030 --> 00:45:08,710
尝试在新的

766
00:45:08,710 --> 00:45:11,110
代码里使用 hook，并且让我们知道

767
00:45:11,110 --> 00:45:15,450
你们是怎么想的。那么，

768
00:45:15,450 --> 00:45:16,310
谢谢大家。

769
00:45:16,310 --> 00:45:20,650
[掌声]

770
00:45:20,650 --> 00:45:22,150
[掌声]

771
00:45:22,150 --> 00:45:25,880
在我们看来，hook 代表着

772
00:45:25,880 --> 00:45:30,800
React 的未来。但我认为

773
00:45:30,800 --> 00:45:34,640
这也代表着我们推进 React 发展的

774
00:45:34,640 --> 00:45:38,540
方式。那就是我们不进行

775
00:45:38,540 --> 00:45:43,190
大的重写。嗯，我们希望我们更喜欢的新模式

776
00:45:43,190 --> 00:45:46,790
可以和旧模式

777
00:45:46,790 --> 00:45:49,820
并存，这样我们就可以进行渐进

778
00:45:49,820 --> 00:45:52,940
迁移并接受这些新模式，就像你们渐进

779
00:45:52,940 --> 00:45:57,890
接受 React 本身一样。这也差不多

780
00:45:57,890 --> 00:46:00,350
是我演讲的结尾了。但是最后，我想讲讲

781
00:46:00,350 --> 00:46:11,690
一些我个人的观点。我从

782
00:46:11,690 --> 00:46:16,990
四年前学习 React。我遇到的

783
00:46:16,990 --> 00:46:20,980
第一个问题就是为什么要使用 JSX。

784
00:46:20,980 --> 00:46:25,520
嗯，我第二个问题是

785
00:46:25,520 --> 00:46:28,730
React 的 logo 到底有

786
00:46:28,730 --> 00:46:32,180
什么含义。React 项目没有起名叫

787
00:46:32,180 --> 00:46:35,660
“原子”（Atom），它并不是一个物理

788
00:46:35,660 --> 00:46:37,610
引擎。

789
00:46:37,610 --> 00:46:40,670
嗯，有一个解释是，React 是

790
00:46:40,670 --> 00:46:41,630
基于

791
00:46:41,630 --> 00:46:44,330
反应的（reactions），原子也参与了

792
00:46:44,330 --> 00:46:48,140
化学反应，因此从 reactions 到 React。呃，

793
00:46:48,140 --> 00:46:50,090
但是 React 没有官方承认过

794
00:46:50,090 --> 00:46:52,400
这种说法。嗯，我发现了一个对我来说

795
00:46:52,400 --> 00:46:57,770
更有意义的解释。我是

796
00:46:57,770 --> 00:46:59,980
这样思考的，呃，

797
00:46:59,980 --> 00:47:02,930
我们知道物质是由

798
00:47:02,930 --> 00:47:07,010
原子组成的。我们学过物质的

799
00:47:07,010 --> 00:47:08,750
外观和行为是由原子

800
00:47:08,750 --> 00:47:11,600
和其内部的属性

801
00:47:11,600 --> 00:47:15,160
决定的。而

802
00:47:15,160 --> 00:47:17,600
React 在我看来是类似的，

803
00:47:17,600 --> 00:47:20,330
你可以使用 React 来构建用户界面，

804
00:47:20,330 --> 00:47:23,120
将其拆分为叫做组件的独立

805
00:47:23,120 --> 00:47:26,480
单元。用户界面的外观和行为

806
00:47:26,480 --> 00:47:29,000
是由这些组件及其

807
00:47:29,000 --> 00:47:32,000
内部的属性

808
00:47:32,000 --> 00:47:35,290
决定的。

809
00:47:35,290 --> 00:47:38,270
具有讽刺意味的是，原子（atom）

810
00:47:38,270 --> 00:47:43,580
一词，字面上的意思是不可分割的。当

811
00:47:43,580 --> 00:47:45,560
科学家们首次发现原子

812
00:47:45,560 --> 00:47:47,090
的时候，他们认为原子是

813
00:47:47,090 --> 00:47:50,690
我们发现的最小的物质。但是

814
00:47:50,690 --> 00:47:53,720
之后他们就发现了电子，电子是

815
00:47:53,720 --> 00:47:55,840
原子内部更小的微粒。

816
00:47:55,840 --> 00:47:58,580
后来证明实际上电子

817
00:47:58,580 --> 00:48:03,770
更能描述原子运行的原理。我

818
00:48:03,770 --> 00:48:05,980
对 hook 也有类似的感觉。我

819
00:48:05,980 --> 00:48:10,000
感觉 hook 不是一个新特性。

820
00:48:10,000 --> 00:48:13,370
我感觉 hook 提供了使用

821
00:48:13,370 --> 00:48:15,830
我们已知的 React 特性

822
00:48:15,830 --> 00:48:18,530
的能力，如 state 、context 和生命周期。

823
00:48:18,530 --> 00:48:26,300
而且我感觉 hook 就像

824
00:48:26,300 --> 00:48:29,290
React 的一个更直观的表现。Hook

825
00:48:29,290 --> 00:48:32,780
在组件内部真正解释了组件

826
00:48:32,780 --> 00:48:36,230
是如何工作的。我感觉 hook 一直

827
00:48:36,230 --> 00:48:38,750
在我们的视线里面隐藏了

828
00:48:38,750 --> 00:48:41,930
四年。事实上，如果看看

829
00:48:41,930 --> 00:48:44,660
React 的 logo，可以看到电子的

830
00:48:44,660 --> 00:48:47,510
轨道，而 hook 好像一直就

831
00:48:47,510 --> 00:48:51,600
在那里。谢谢。

832
00:48:51,600 --> 00:48:57,440
[掌声]

833
00:48:57,440 --> 00:49:04,620
[掌声]

834
00:49:04,620 --> 00:49:07,270
Dan，非常感谢你。Sophie，也谢谢

835
00:49:07,270 --> 00:49:09,000
你。
